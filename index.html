<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Follow the Easter Bunny's magical journey around the world in real-time! Watch as he delivers Easter baskets to children globally, with live tracking, stats, and an interactive tracking map. üê∞‚ú®">
<meta name="keywords" content="Easter Bunny Tracker, Easter Bunny, Easter 2025, Live Tracking, Easter Basket Delivery, Easter Map, Easter Journey, Easter Egg Hunt, Easter 2025 Countdown, Easter Bunny Live, Easter Bunny Tracking, Easter Gifts, Easter Traditions, Easter Day 2025, Easter Celebration, Easter Morning, Easter Fun, Easter Activities, Easter Bunny Locations, Easter Morning Tracker, Easter Bunny 2025, Easter Hunt, Easter Adventure, Easter Bunny GPS, Easter Tracking Map, Easter Fun Tracker, Easter Basket, Easter Treats, Easter Surprise, Easter Bunny Arrival, Easter 2025 Fun, Easter Countdown, Easter Celebration Tracker, Easter Bunny Adventure, Real Time Easter Tracker, Easter Family Fun, Easter Tracking App, Easter Bunny Updates, Easter Tracker App, Easter Bunny Journey, Easter Day Tracking, Easter Bunny Online, Easter Bunny Fun Tracker, Easter Bunny Fun, Easter 2025 Events, Easter Bunny News, Easter Egg Delivery, Easter Bunny Live Stream, Easter Morning Tracker, Easter Bunny Gift Delivery, Easter Bunny Route, Track Easter Bunny, Easter Bunny on Map, Easter Bunny 2025 Tracker, Easter Egg Map, Easter Bunny Worldwide, Easter Bunny Route Tracker, Easter Basket Tracker, Easter Bunny Watch, Track Easter Bunny in Real Time, Easter Bunny Distance, Easter Bunny Path, Easter Day Celebration, Easter Bunny Updates Live">
    <title>Easter Bunny's Journey Tracking 2025 üê∞üó∫Ô∏è
</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.33/moment-timezone-with-data.min.js"></script>

<link rel="icon" type="image/png" href="icon.png">
<noscript>
    <meta http-equiv="refresh" content="0;url=jsdisabled.html">
</noscript>

<meta property="og:title" content="Easter Bunny Tracker 2025 - Live Tracking üê∞">
<meta property="og:description" content="Follow the Easter Bunny's magical journey around the world in real-time! Watch as he delivers Easter baskets to children globally. Interactive map and live stats! üó∫Ô∏è‚ú®">
<meta property="og:url" content="https://speechless-parrot.github.io/bunny-journey-tracking">
<meta property="og:type" content="website">

<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Easter Bunny Tracker 2025 üê∞">
<meta name="twitter:description" content="Track the Easter Bunny's magical journey around the world in real-time! Live map, stats, and delivery tracking. üó∫Ô∏è‚ú®">

<meta name="robots" content="index, follow">
<meta name="theme-color" content="#ff69b4">
<meta http-equiv="content-language" content="en">
<link rel="canonical" href="https://speechless-parrot.github.io/bunny-journey-tracking">

<link rel="preconnect" href="https://api.open-meteo.com">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="dns-prefetch" href="https://api.open-meteo.com">
<link rel="dns-prefetch" href="https://fonts.googleapis.com">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Easter Bunny Tracker 2025",
  "description": "Real-time tracking of the Easter Bunny's global journey delivering Easter baskets to children worldwide.",
  "url": "https://speechless-parrot.github.io/bunny-journey-tracking",
  "applicationCategory": "Map, Tracking",
  "operatingSystem": "All",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "author": {
    "@type": "Person",
    "name": "speechless-parrot"
  },
  "temporalCoverage": "2025-04-20"
}
</script>

<noscript>
    <meta http-equiv="refresh" content="0; URL=jsdisabled.html">
</noscript>
    
    <!-- Google Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Google Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Symbols+Rounded" rel="stylesheet">
    <!-- Lobster Font -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka&display=swap" rel="stylesheet">
    <!-- Google Sans Font -->
    <link href="https://fonts.googleapis.com/css?family=Google+Sans:100,300,400,500,700,900,100i,300i,400i,500i,700i,900i" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">

    
<!-- Keep the same HTML structure but update the style section -->
<style>
/* Set Google Sans as the default body font */
body, p, span {
    font-family: 'Google Sans', Arial, sans-serif;
    /* Keeping it nice and readable */
    font-weight: 400;
}

/* Use Fredoka for headings and special elements */
h1, h2, h3, h4, h5, h6, 
.special-text, 
.santa-title {
    font-family: 'Fredoka', cursive;
}

/* If you want different weights for different elements */
.light-text {
    font-weight: 300;
}

.bold-text {
    font-weight: 700;
}
    body {
        overflow: hidden;
    }

    #map {
        width: 100vw;
        height: 100vh; /* üÜï Map now takes full height */
        position: absolute;
        top: 0;
        z-index: 1;
    }

    .header {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
  text-align: center;
        font-size: 2.5rem;
        color: #ff69b4; /* Pastel pink */
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* üÜï Stronger text shadow */
        transition: all 0.3s ease;
        /* üÜï Removed background-color */
    }

    .header:hover {
        transform: translateX(-50%) scale(1.05);
    }

    .controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 2;
        display: flex;
        gap: 10px;
    }

    .control-btn {
        background-color: rgba(255, 255, 255, 0.8);
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .control-btn:hover {
        background-color: #ff69b4; /* Pastel pink */
        color: white;
        transform: scale(1.1);
    }

    .stats-container {
        position: fixed;
        bottom: 0;
        width: 100%;
        background: rgba(255, 255, 255, 0.85);
        padding: 20px;
        z-index: 2;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
    }

    .stat-item {
        text-align: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }

    .stat-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .stat-label {
    font-family: 'Fredoka', cursive;
        font-size: 1rem;
        color: #333;
        margin-bottom: 8px;
    }

    .stat-value {
        font-size: 1.3rem;
        color: #ff69b4; /* Pastel pink */
    }

    /* üÜï Updated media queries for better responsiveness */
    @media (max-width: 1024px) {
        .stats-container {
        font-size: 14px;
        padding: 12px;
            gap: 15px;
        }
        
        .stat-item {
            padding: 10px;
        }
    }

    @media (max-width: 768px) {
        .header {
            font-size: 1.8rem;
            top: 80px; /* üÜï Moved header below controls on medium screens */
            text-align: center;
        }

        .stats-container {
            grid-template-columns: repeat(3, 1fr);
            padding: 10px;
        }
    /* Make the stop details card take full width */
    .stop-details-card {
        grid-column: 1 / -1; /* This makes it span all columns */
        order: -1; /* This moves it to the top */
    }
    /* Make the status stat take full width */
    .status-stat {
        grid-column: 1 / -1; /* This makes it span all columns */
        order: -1; /* This moves it to the top */
    }

        .stat-label {
            font-size: 0.9rem;
        }

        .stat-value {
            font-size: 0.9rem;
        }
    }

    @media (max-width: 480px) {
        .header {
            font-size: 1.5rem;
            width: 80%;
            text-align: center;
        }

        .stats-container {
            grid-template-columns: repeat(2, 1fr);
            max-height: 30vh; /* üÜï Limit height on small screens */
            overflow-y: auto; /* üÜï Make stats scrollable if needed */
        }

        .control-btn {
            width: 35px;
            height: 35px;
        }

        .stat-label {
            font-size: 0.8rem;
        }

        .stat-value {
            font-size: 1rem;
        }
    }

    @media (max-width: 360px) {
        .stats-container {
            grid-template-columns: 1fr;
            max-height: 25vh; /* üÜï Even smaller height on very small screens */
        }
    }

/* Tablet/Medium screens */
@media (max-width: 1024px) {
    .stats-container {
        font-size: 14px;
        padding: 12px;
        gap: 12px;
        grid-template-columns: repeat(4, 1fr); /* Show 4 items per row on tablets */
    }
    
    .stat-item {
        padding: 10px;
    }

    .stat-label {
        font-size: 0.9rem;
    }

    .stat-value {
        font-size: 1.1rem;
    }

    .material-symbols-rounded {
        font-size: 1.1rem !important;
    }
}

/* Smaller tablets */
@media (max-width: 768px) {
    .header {
        font-size: 1.8rem;
        top: 80px;
    }

    .stats-container {
        grid-template-columns: repeat(3, 1fr);
        padding: 10px;
        gap: 10px;
    }

    .stat-item {
        padding: 8px;
    }

    .stat-label {
        font-size: 0.85rem;
        margin-bottom: 4px;
    }
    .departing-arriving {
    margin-top: 20px;
        font-size: 0.85rem;
        margin-bottom: 4px;
    }

    .stat-value {
        font-size: 0.9rem;
    }

    .material-symbols-rounded {
        font-size: 1rem !important;
    }
}

    /* üÜï Add smooth scrollbar for stats container */
    .stats-container::-webkit-scrollbar {
        width: 6px;
    }

    .stats-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
    }

    .stats-container::-webkit-scrollbar-thumb {
        background: rgba(255, 182, 193, 0.5); /* Light pink */
        border-radius: 3px;
    }
/* Custom Bunny marker style */
.bunny-marker {
    font-size: 2rem;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
}
.stat-label .material-icons {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}
.departing-arriving .material-icons {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}
.departing-arriving .material-symbols-rounded {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}
.stat-label .material-symbols-rounded {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}

.presents-info .material-symbols-rounded {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}

.wiki-info .material-symbols-rounded {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}

.arrival-info .material-symbols-rounded {
    font-size: 1.2rem;
    vertical-align: middle;
    margin-right: 5px;
    color: #ff69b4; /* Pastel pink */
}

.stat-label {
    display: flex;
    align-items: center;
    gap: 5px;
}
#currentStopValue {
    margin-bottom: 10px;  /* Adds space below the stat value */
}

#departingLabel {
    margin-top: 10px;  /* Adds space above the stat label */
}

#distanceValue {
    margin-bottom: 10px;  /* Adds space below the stat value */
}

#citiesLabel {
    margin-top: 10px;  /* Adds space above the stat label */
}
#presentsValue {
    margin-bottom: 10px;  /* Adds space below the stat value */
}

#cookiesLabel {
    margin-top: 10px;  /* Adds space above the stat label */
}
/* Style the popup container with Google Sans */
.stop-info-container {
    font-family: 'Google Sans', Arial, sans-serif;
}

/* Make just the stop title use Fredoka */
.stop-title {
    font-family: 'Fredoka', cursive;
    /* Optional: make it a bit bigger and add some spacing */
    font-size: 1.2em;
    margin-bottom: 10px;
}

/* Ensure other popup elements use Google Sans */
.photo-attribution,
.presents-info,
.stop-info {
    font-family: 'Google Sans', Arial, sans-serif;
}

/* If you're using Leaflet's default popup class, you might also need: */
.leaflet-popup-content {
    font-family: 'Google Sans', Arial, sans-serif;
}

.location-tooltip {
    font-family: 'Google Sans', Arial, sans-serif;
    border-radius: 8px;
    padding: 8px 12px;
}

.stop-details-card {
    position: relative;
    overflow: hidden;
    padding: 10px;
}

.stop-content {
    position: relative;
}

.stop-header {
    margin-bottom: 8px;
}

.stop-extra-info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
    font-size: 0.85em;
    margin: 8px 0;
}

.info-item {
    display: flex;
    align-items: center;
    gap: 4px;
    background: rgba(0, 0, 0, 0.05);
    padding: 4px 8px;
    border-radius: 4px;
}

.wiki-link {
    display: flex;
    align-items: center;
    gap: 4px;
    text-decoration: none;
    color: #ff69b4; /* Pastel pink */
    background: rgba(255, 105, 180, 0.1);
    padding: 4px 8px;
    border-radius: 4px;
}

.wiki-link:hover {
    background: rgba(255, 105, 180, 0.2);
}

.depart-info {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* Make sure icons are the right size */
.info-item .material-symbols-rounded,
.wiki-link .material-symbols-rounded {
    font-size: 1.1em;
}
.cookies-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.cities-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}
.speed-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}
.weather-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}
.timezone-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}
.stop-content {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}
    .next-update {
        margin-top: 12px;
        font-size: 0.9em;
        color: #86868b;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        display: inline-block;
        backdrop-filter: blur(8px);
    }

    .santa-update-image {
        max-width: 180px !important;
        border-radius: 12px !important;
        display: block !important;
        margin: 8px auto !important;
    }
    #statusValue iframe {
        width: 100%;
        max-width: 250px;
        height: 140px;
        border-radius: 12px;
        border: none;
        display: block;
        margin: 8px auto;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


#loadingScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    width: 100%;
    background: #ff69b4; /* Pastel pink background */
    color: #fff;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 4;
    text-align: center;
    transition: opacity 2s ease-out;
}

#loadingScreen h1 {
    font-family: 'Fredoka', cursive;
    font-size: 3rem;
    margin-bottom: 1rem;
}

#progressContainer {
    width: 80%;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 1rem;
}

#progressBar {
    width: 0;
    height: 20px;
    background: #fff;
    border-radius: 10px;
    transition: width 0.5s ease;
}

.hidden {
    display: none;
}

.fade-out {
    opacity: 0;
    transition: opacity 2s ease-out;
}

.icon-img {
    width: 24px; /* Adjust the size as needed */
    height: 24px; /* Adjust the size as needed */
    vertical-align: middle; /* Aligns the icon with the text */
}

.info-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    text-align: center;
}

.button {
    text-decoration: none;
    color: white;
    background-color: #007BFF;
    padding: 10px;
    text-align: center;
    border-radius: 5px;
    font-size: 16px;
}

.button:hover {
    background-color: #0056b3;
}
/* Add to styles */
#statusValue {
    line-height: 1.4;
    padding: 0.5rem;
}

/* Add class for long updates */
#statusValue.long-update {
    font-size: 0.9em;
}
/* Destination tooltip styling üéØ */
.destination-tooltip {
    /* Font styling ‚ú® */
    font-family: 'Google Sans', 'Product Sans', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 13px;
    font-weight: 400;
    letter-spacing: 0.2px;
    line-height: 1.4;
    
    /* Background and border üé® */
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: none;
    
    /* Modern shadow for depth üåü */
    box-shadow: 
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06),
        0 0 0 1px rgba(255, 255, 255, 0.3);
    
    /* Smooth corners and padding ‚≠ê */
    border-radius: 12px;
    padding: 8px 12px;
    
    /* Animation for showing/hiding üîÑ */
    transition: all 0.2s ease;
    
    /* Text color and alignment üìù */
    color: #1a1a1a;
    text-align: center;
    
    /* Remove default tooltip arrow */
    &:before {
        display: none;
    }
}

/* Hover state enhancement ‚ú® */
.destination-tooltip:hover {
    background-color: rgba(255, 255, 255, 0.96);
    transform: translateY(-1px);
    box-shadow: 
        0 6px 8px -1px rgba(0, 0, 0, 0.12),
        0 3px 6px -1px rgba(0, 0, 0, 0.08),
        0 0 0 1px rgba(255, 255, 255, 0.4);
}

/* Optional: Add a custom arrow üîΩ */
.destination-tooltip:after {
    content: '';
    position: absolute;
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 12px;
    background: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow: 2px 2px 2px rgba(0, 0, 0, 0.06);
    transform: translateX(-50%) rotate(45deg);
    z-index: -1;
}

/* Optional: Add emoji size consistency üéØ */
.destination-tooltip img,
.destination-tooltip span {
    vertical-align: middle;
    font-size: 14px; /* For emoji */
    margin-right: 4px;
}


/* Popup base styles */
.custom-popup {
    font-family: 'Google Sans', 'Product Sans', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
    max-width: 400px; /* Increased from 300px */
    min-width: 350px; /* Added minimum width */
    padding: 0;
    margin: 0;
}

/* Popup wrapper */
.custom-popup .leaflet-popup-content-wrapper {
    border-radius: 16px;
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    padding: 0;
}

/* Popup content */
.custom-popup .leaflet-popup-content {
    margin: 0;
    padding: 16px;
}

/* Popup tip */
.custom-popup .leaflet-popup-tip {
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

/* Popup header */
.popup-header {
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    color: #1a1a1a;
}

/* Stat container */
.popup-stat {
    display: flex;
    align-items: flex-start;
    margin-bottom: 10px;
    font-size: 13px;
    line-height: 1.4;
}

/* Material icons in stats */
.popup-stat .material-symbols-rounded {
    font-size: 20px;
    margin-right: 8px;
    color: #ff69b4;
    flex-shrink: 0;
}

/* Image icons in stats */
.popup-stat .icon-image {
    font-size: 20px;
    margin-right: 8px;
    color: #ff69b4;
    flex-shrink: 0;
}

/* Stat content */
.popup-stat-content {
    color: #333;
    flex: 1;
}

/* Stat labels */
.popup-stat-label {
    font-weight: 500;
    color: #666;
    font-size: 12px;
    display: block;
    margin-bottom: 2px;
}

/* Overview section */
.popup-overview {
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* Wikipedia description */
.popup-description {
    font-size: 12px;
    color: #666;
    font-style: italic;
    margin-bottom: 8px;
}

/* Wikipedia extract */
.popup-extract {
    font-size: 13px;
    line-height: 1.5;
    color: #333;
    margin-bottom: 12px;
    max-height: 150px;
    overflow-y: auto;
    word-wrap: break-word;
    scroll-behavior: smooth;
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 0, 0, 0.3) transparent;
    padding-right: 8px;
}

/* Webkit scrollbar styling */
.popup-extract::-webkit-scrollbar {
    width: 6px;
}

.popup-extract::-webkit-scrollbar-track {
    background: transparent;
}

.popup-extract::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 3px;
}

/* Wikipedia link */
.popup-wiki-link {
    display: inline-flex;
    align-items: center;
    color: #2196f3;
    text-decoration: none;
    font-size: 13px;
    font-weight: 500;
}

.popup-wiki-link:hover {
    text-decoration: underline;
}

.popup-wiki-link .material-symbols-rounded {
    font-size: 16px;
    margin-left: 4px;
}

/* Tooltip styles */
.destination-tooltip {
    font-family: 'Google Sans', 'Product Sans', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 13px;
    font-weight: 400;
    letter-spacing: 0.2px;
    line-height: 1.4;
    background-color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: none;
    box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(0, 0, 0, 0.05);
    border-radius: 12px;
    padding: 8px 12px;
    color: #333;
    white-space: nowrap;
    transition: all 0.2s ease;
}

/* Tooltip hover effect */
.destination-tooltip:hover {
    background-color: rgba(255, 255, 255, 0.98);
    transform: translateY(-1px);
    box-shadow: 
        0 4px 6px rgba(0, 0, 0, 0.12),
        0 0 0 1px rgba(0, 0, 0, 0.08);
}

/* Hide default tooltip arrow */
.leaflet-tooltip-top:before,
.leaflet-tooltip-bottom:before,
.leaflet-tooltip-left:before,
.leaflet-tooltip-right:before {
    display: none !important;
}
/* Settings popup styles */
.modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(2px);
    z-index: 1000;
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.modal-backdrop.active {
    opacity: 1;
}

.settings-popup {
    position: fixed;
    top: 0;
    right: -400px;
    width: 400px;
    height: 100%;
    background: #fff;
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
    z-index: 1001;
    display: none;
    overflow-y: auto;
    padding: 24px;
    transition: right 0.3s ease;
}

.settings-popup.active {
    right: 0;
}

.settings-popup h2 {
    font-size: 24px;
    margin-bottom: 24px;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
}

.settings-close {
    position: absolute;
    top: 0;
    right: 0;
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.settings-close:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

.settings-category {
    margin-bottom: 32px;
}

.settings-category h3 {
    font-size: 18px;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.settings-option {
    margin-bottom: 12px;
}

.checkbox-option, .radio-option {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.checkbox-option:hover, .radio-option:hover {
    background-color: rgba(255, 105, 180, 0.1);
}

.settings-footnote {
    font-size: 12px;
    color: #666;
    padding: 16px 0;
    border-top: 1px solid #eee;
    margin-top: 24px;
}

/* Style inputs with Material Design */
.settings-popup input[type="checkbox"],
.settings-popup input[type="radio"] {
    accent-color: #ff69b4;
    cursor: pointer;
    transition: all 0.2s ease;
}

.settings-popup label {
    user-select: none;
    flex: 1;
    padding: 4px 0;
}

/* Scrollbar styling */
.settings-popup::-webkit-scrollbar {
    width: 8px;
}

.settings-popup::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.settings-popup::-webkit-scrollbar-thumb {
    background: #ff69b4;
    border-radius: 4px;
}

.settings-popup::-webkit-scrollbar-thumb:hover {
    background: #ff45a4;
}

/* Prevent text selection */
.settings-popup {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Material Icons alignment */
.material-symbols-rounded {
    display: flex;
    align-items: center;
    justify-content: center;
}
/* Add this to your CSS */
.info-content {
    font-size: 14px;
    line-height: 1.6;
}

.welcome-message {
    background: #fff5f9;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 24px;
    border: 1px solid #ffe0ef;
}

.guide-section {
    margin-bottom: 24px;
}

.guide-section h3 {
    font-size: 18px;
    margin-bottom: 12px;
    color: #ff69b4;
    display: flex;
    align-items: center;
    gap: 8px;
}

.guide-list {
    list-style: none;
    padding: 0;
}

.guide-list li {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: #fff;
    border-radius: 8px;
    margin-bottom: 8px;
    border: 1px solid #eee;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.guide-list li:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.guide-icon {
    width: 24px;
    height: 24px;
    object-fit: contain;
}

.useful-links {
    background: #f8f9fa;
    padding: 16px;
    border-radius: 8px;
    margin-bottom: 24px;
}

.useful-links ul {
    list-style: none;
    padding: 0;
}

.useful-links li {
    margin-bottom: 8px;
}

.useful-links a {
    color: #ff69b4;
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.useful-links a:hover {
    background-color: #fff;
    text-decoration: underline;
}

.info-footnote {
    font-size: 12px;
    color: #666;
    padding: 16px 0;
    border-top: 1px solid #eee;
    margin-top: 24px;
}

.info-footnote a {
    color: #666;
    text-decoration: none;
}

.info-footnote a:hover {
    text-decoration: underline;
}
.countdown-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #fff5f9 0%, #ffe0ef 100%);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1;
    transition: opacity 0.5s ease-in-out;
}

.countdown-overlay.hiding {
    opacity: 0;
    pointer-events: none;
}

.countdown-close {
    position: absolute;
    top: 20px;
    background: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease;
}

.countdown-close:hover {
    transform: scale(1.1);
}

/* Position the close button */
.countdown-close:nth-child(1) {
    right: 20px;
}

/* Position the fullscreen button */
.countdown-close:nth-child(2) {
    right: 70px; /* 20px + 10px gap + 40px width of first button */
}

.countdown-container {
    text-align: center;
    padding: 2rem;
    max-width: 800px;
}

.countdown-container h1 {
    color: #ff69b4;
    font-size: 2.5rem;
    margin-bottom: 2rem;
    animation: fadeInUp 0.8s ease;
}

.countdown-timer {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin: 2rem 0;
    animation: fadeInUp 0.8s ease 0.2s both;
}

.countdown-section {
    background: white;
    padding: 1.5rem;
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    min-width: 120px;
    transition: transform 0.2s ease;
}

.countdown-section:hover {
    transform: translateY(-5px);
}

.countdown-value {
    font-size: 3.5rem;
    font-weight: bold;
    color: #ff69b4;
    line-height: 1;
    margin-bottom: 0.5rem;
}

.countdown-label {
    font-size: 1rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.countdown-divider {
    font-size: 3rem;
    color: #ff69b4;
    font-weight: bold;
    animation: pulse 1s infinite;
}

.countdown-message {
    margin: 2rem 0;
    animation: fadeInUp 0.8s ease 0.4s both;
}

.countdown-message p {
    font-size: 1.2rem;
    color: #666;
    margin: 0.5rem 0;
}

.useful-links {
    margin: 2rem 0;
    animation: fadeInUp 0.8s ease 0.6s both;
}

.useful-links h3 {
    color: #ff69b4;
    margin-bottom: 1rem;
}

.useful-links ul {
    list-style: none;
    padding: 0;
    display: flex;
    justify-content: center;
    gap: 1.5rem;
}

.useful-links a {
    color: #666;
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 8px;
    background: white;
    display: inline-block;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.useful-links a:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.info-footnote {
    margin-top: 2rem;
    font-size: 0.8rem;
    color: #666;
    animation: fadeInUp 0.8s ease 0.8s both;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

@media (max-width: 768px) {
    .countdown-timer {
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    
    .countdown-section {
        min-width: 80px;
        padding: 1rem;
    }
    
    .countdown-value {
        font-size: 2.5rem;
    }
    
    .countdown-divider {
        font-size: 2rem;
    }
    
    .countdown-container h1 {
        font-size: 2rem;
    }
}
.countdown-container {
    text-align: center;
    padding: 2rem;
    max-width: 800px;
    width: 100%; /* Add this to ensure full width */
    margin: auto; /* Add this to help with centering */
    display: block;         /* Add these four properties */
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

/* To ensure all inner content is also centered */
.countdown-timer,
.countdown-message,
.useful-links,
.info-footnote {
    width: 100%; /* Add this to ensure full width alignment */
}

/* If the useful links are still not centered */
.useful-links ul {
    justify-content: center; /* Ensure this is set */
    width: 100%; /* Add this if needed */
}
/* Loading screen - should be higher than countdown */
#loadingScreen {
    z-index: 10000; /* Higher than countdown overlay */
}

/* Countdown overlay - should be lower than loading screen */
#countdownOverlay {
    z-index: 9000; /* Lower than loading screen */
}
/* Add this media query for devices with low height */
@media screen and (max-height: 700px) { /* Adjust this value based on your needs */
    .stats-container {
        max-height: 40vh; /* Limit height to 40% of viewport height */
        overflow-y: auto; /* Enable vertical scrolling */
        scrollbar-width: thin; /* For Firefox */
        -ms-overflow-style: none; /* For Internet Explorer and Edge */
    }

    /* Style the scrollbar for Webkit browsers */
    .stats-container::-webkit-scrollbar {
        width: 6px;
    }

    .stats-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
    }

    .stats-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
    }

    .stats-container::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
    }

    /* Optional: Adjust padding/margins for better fit */
    .stat-item {
        padding: 8px 15px; /* Slightly reduced padding */
    }
}
/* Dark Mode Styles for Map Elements and Metrics */
[data-theme="dark"] {
    /* Variables remain the same */
    --background-primary: #121212;
    --background-secondary: #1e1e1e;
    --text-primary: #ffffff;
    --text-secondary: #e0e0e0;
    --card-background: rgba(30, 30, 30, 0.95);
    --card-border: #333333;
    --metric-background: rgba(30, 30, 30, 0.9);
    --metric-border: #333333;
    --popup-background: #1e1e1e;
    --tooltip-background: #1e1e1e;
    --info-list-background: #252525;
    --info-text: #ffffff;
}

/* Stats Container Dark Mode */
[data-theme="dark"] .stats-container {
    background-color: var(--background-primary);
}

/* Individual Stat Items Dark Mode */
[data-theme="dark"] .stat-item {
    background-color: var(--metric-background);
    border-color: var(--metric-border);
}

/* Stat Labels Dark Mode */
[data-theme="dark"] .stat-label {
    color: var(--text-secondary);
}

[data-theme="dark"] .stat-label .material-symbols-rounded,
[data-theme="dark"] .stat-label .material-icons {
    color: var(--text-secondary);
}

/* Stat Values Dark Mode */
[data-theme="dark"] .stat-value {
    color: var(--text-primary);
}

/* Specific Sections Dark Mode */
[data-theme="dark"] .stop-details-card,
[data-theme="dark"] .presents-cookies,
[data-theme="dark"] .status-stat,
[data-theme="dark"] .arrival-stat,
[data-theme="dark"] .extra-stats {
    background-color: var(--metric-background);
    border-color: var(--metric-border);
}

/* Section Content Dark Mode */
[data-theme="dark"] .last-seen-section,
[data-theme="dark"] .stop-content,
[data-theme="dark"] .presents-section,
[data-theme="dark"] .cookies-section,
[data-theme="dark"] .distance-section,
[data-theme="dark"] .speed-section,
[data-theme="dark"] .weather-section {
    color: var(--text-primary);
}

/* Map Tooltips and Popups Dark Mode */
[data-theme="dark"] .leaflet-popup-content-wrapper,
[data-theme="dark"] .leaflet-popup-tip {
    background-color: var(--popup-background);
    color: var(--text-primary);
}

/* Map Popups Dark Mode */
[data-theme="dark"] .leaflet-popup-content-wrapper,
[data-theme="dark"] .leaflet-popup-tip {
    background-color: var(--popup-background);
}

/* Target the popup content and all text elements inside it */
[data-theme="dark"] .leaflet-popup-content,
[data-theme="dark"] .leaflet-popup-content p,
[data-theme="dark"] .leaflet-popup-content span,
[data-theme="dark"] .leaflet-popup-content div {
    color: var(--text-primary) !important;
}

/* Make links visible but distinct in dark mode */
[data-theme="dark"] .leaflet-popup-content a {
    color: #66b3ff;
}

/* Transitions */
.stats-container,
.stat-item,
.stat-label,
.stat-value,
.leaflet-popup-content-wrapper,
.leaflet-tooltip {
    transition: background-color 0.3s ease, 
                color 0.3s ease, 
                border-color 0.3s ease;
}

/* Icons in Dark Mode */
[data-theme="dark"] .icon-img {
    filter: brightness(1.2); /* Makes the icons slightly brighter in dark mode */
}
/* Offline notification text styles */
#offline-notification {
  color: #ff69b4; /* Pastel pink */
  font-family: 'Google Sans', Arial, sans-serif;
  font-size: 1rem; /* Smaller font size */
  text-align: center;
  position: absolute;
  top: 175px; /* Lower than the header */
  left: 50%;
  transform: translateX(-50%);
  z-index: 2;
  background: rgba(255, 255, 255, 0.8);
  padding: 5px; /* Smaller padding */
  border-radius: 10px;
  display: flex;
  align-items: center;
  gap: 5px; /* Smaller gap */
  transition: opacity 0.5s ease; /* Smooth fade-out transition */
}

#offline-notification .material-symbols-rounded {
  font-size: 20px; /* Slightly smaller icon */
}

#offline-notification .close-icon {
  cursor: pointer;
  font-size: 16px; /* Adjust size as needed */
  margin-left: 10px;
}

/* Fade-out animation */
#offline-notification.fade-out {
  opacity: 0;
}
/* Mobile Stats Container */
.stats-container-mobile {
    display: none; /* Hidden by default */
    position: fixed;
    bottom: 0;
    width: 100%;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 12px;
    z-index: 1000;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
}

/* Mobile Header Section */
.mobile-header-section {
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.mobile-stop-info {
    margin-bottom: 4px;
}

.mobile-stop-label {
    display: flex;
    align-items: center;
    gap: 4px;
    color: #666;
    font-size: 0.9rem;
}

.mobile-stop-value {
    font-size: 1.1rem;
    font-weight: 500;
    margin-top: 2px;
}

.mobile-meta-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.85rem;
    color: #666;
    margin-top: 8px;
}

.mobile-time-weather {
    display: flex;
    align-items: center;
    gap: 4px;
}

.mobile-time-weather .divider {
    margin: 0 4px;
    opacity: 0.5;
}

.mobile-status {
    text-align: right;
    font-size: 0.85rem;
}

/* Mobile Stats Grid */
.mobile-stats-section {
    padding: 8px 0;
}

.mobile-stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
}

.mobile-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.mobile-stat .mobile-icon {
    width: 20px;
    height: 20px;
}

.mobile-stat .material-symbols-rounded {
    font-size: 20px;
    color: #ff69b4;
}

.mobile-stat span:last-child {
    font-size: 0.85rem;
    font-weight: 500;
}

/* Mobile Arrival Section */
.mobile-arrival-section {
    font-size: 0.85rem;
    color: #666;
    display: flex;
    align-items: center;
    gap: 6px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

/* Dark mode support */
[data-theme="dark"] .stats-container-mobile {
    background: rgba(30, 30, 30, 0.95);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

[data-theme="dark"] .mobile-stop-label,
[data-theme="dark"] .mobile-meta-info,
[data-theme="dark"] .mobile-arrival-section {
    color: #aaa;
}

[data-theme="dark"] .mobile-stop-value {
    color: #fff;
}

/* Media Queries */
@media (max-width: 768px) {
    .stats-container {
        display: none; /* Hide desktop stats */
    }
    
    .stats-container-mobile {
        display: block; /* Show mobile stats */
    }

    /* Adjust map height to account for mobile stats */
    #map {
        height: calc(100vh - 130px); /* Adjust based on your mobile stats height */
    }
}

/* Smaller screens */
@media (max-width: 480px) {
    .mobile-stats-grid {
        grid-template-columns: repeat(2, 1fr); /* Stack in two columns on very small screens */
        gap: 12px;
    }

    .mobile-meta-info {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
    }

    .mobile-status {
        text-align: left;
        margin-top: 4px;
    }
}

/* Add safe area padding for modern mobile browsers */
@supports (padding: max(0px)) {
    .stats-container-mobile {
        padding-bottom: max(12px, env(safe-area-inset-bottom));
    }
}

/* Add to your existing mobile CSS */
.mobile-arrival-status {
    display: inline-flex;
    align-items: center;
    gap: 4px;
}

.mobile-last-seen {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-top: 4px;
    font-size: 0.85rem;
    color: #666;
}

.last-seen-label {
    font-weight: 500;
}

.mobile-arrival-section {
    cursor: pointer;
    padding: 8px 0;
    transition: opacity 0.2s ease;
}

.mobile-arrival-section:hover {
    opacity: 0.8;
}

.clickable {
    cursor: pointer;
}

/* Dark mode updates */
[data-theme="dark"] .mobile-last-seen {
    color: #aaa;
}

/* Adjust the meta info layout */
.mobile-meta-info {
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
}

.mobile-time-weather {
    width: 100%;
    justify-content: flex-start;
    flex-wrap: wrap;
}
.mobile-stat-item {
    padding: 12px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.mobile-stat-label {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 4px;
}

.mobile-stat-value {
    font-size: 1rem;
    font-weight: 500;
}

/* Dark mode support */
[data-theme="dark"] .mobile-stat-item {
    border-color: rgba(255, 255, 255, 0.1);
}

[data-theme="dark"] .mobile-stat-label {
    color: #aaa;
}

[data-theme="dark"] .mobile-stat-value {
    color: #fff;
}
.meta-info-mobile {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    color: #666;
    padding: 8px 0;
}

.meta-label-mobile {
    color: inherit;
}

/* Dark mode support */
[data-theme="dark"] .meta-info-mobile {
    color: #aaa;
}

</style>
</head>
<body>

<div id="loadingScreen">
    <h1>Loading... üê∞</h1>
    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <p id="loadingMessage">Connecting to Easter Island... üèùÔ∏è</p>
</div>

<!-- Add this right after your body tag -->
<div class="countdown-overlay" id="countdownOverlay">
<button class="countdown-button countdown-close" onclick="dismissCountdown()">
    <span class="material-symbols-rounded">close</span>
</button>
<button class="countdown-button countdown-close" onclick="toggleFullscreen()">
    <span class="material-symbols-rounded">fullscreen</span>
</button>
    
    <div class="countdown-container">        
        <div class="countdown-timer">
            <div class="countdown-section">
                <div class="countdown-value" id="countDays">00</div>
                <div class="countdown-label">Days</div>
            </div>
            <div class="countdown-divider">:</div>
            <div class="countdown-section">
                <div class="countdown-value" id="countHours">00</div>
                <div class="countdown-label">Hours</div>
            </div>
            <div class="countdown-divider">:</div>
            <div class="countdown-section">
                <div class="countdown-value" id="countMinutes">00</div>
                <div class="countdown-label">Minutes</div>
            </div>
            <div class="countdown-divider">:</div>
            <div class="countdown-section">
                <div class="countdown-value" id="countSeconds">00</div>
                <div class="countdown-label">Seconds</div>
            </div>
        </div>

        <h3>until the Easter Bunny's journey begins ‚è≥</h3>

        <div class="countdown-message">
            <p>üê∞ Get ready for a magical journey around the world! üåç</p>
        </div>
    </div>
</div>

<!-- Update the HTML with close button -->
<div class="modal-backdrop"></div>
<div class="settings-popup">
    <h2>
        <span class="material-symbols-rounded">settings</span> 
        Tracker Settings
        <span class="settings-close material-symbols-rounded">close</span>
    </h2>
    
    <div class="settings-category">
        <h3><span class="material-symbols-rounded">monitoring</span> Display Metrics</h3>
        <div class="settings-option">
            <label class="checkbox-option">
                <input type="checkbox" id="setting-location-info" checked>
                Location info (last seen, next/current stop & arriving/departing in time) üó∫Ô∏è
            </label>
            <label class="checkbox-option">
                <input type="checkbox" id="setting-delivery-stats" checked>
                Delivery stats (baskets delivered & carrots eaten) üß∫ü•ï
            </label>
            <label class="checkbox-option">
                <input type="checkbox" id="setting-island-status" checked>
                Easter Island status (shown before main tracking begins) üí¨
            </label>
            <label class="checkbox-option">
                <input type="checkbox" id="setting-arrival-time" checked>
                Estimated arrival time for your location ‚è∞
            </label>
            <label class="checkbox-option">
                <input type="checkbox" id="setting-additional-stats" checked>
                Additional stats (speed, distance & weather) üìä
            </label>
    <div class="settings-footnote">
        üîí Pro tip: If you're streaming the tracker, we recommend turning off the estimated arrival time metric to avoid accidentally revealing your location! üé•
    </div>
        </div>
    </div>

<!-- Add this after your Temperature Unit section -->
<div class="settings-category">
    <h3><span class="material-symbols-rounded">dark_mode</span> Theme</h3>
    <div class="settings-option">
        <label class="checkbox-option">
            <input type="checkbox" id="setting-dark-mode">
            Dark mode
        </label>
    </div>
</div>

    <div class="settings-category">
        <h3><span class="material-symbols-rounded">speed</span> Speed & Distance Units</h3>
        <div class="settings-option">
            <label class="radio-option">
                <input type="radio" name="units" id="setting-metric" checked>
                Metric (km/h & km)
            </label>
            <label class="radio-option">
                <input type="radio" name="units" id="setting-imperial">
                Imperial (mph & miles)
            </label>
        </div>
    </div>

    <div class="settings-category">
        <h3><span class="material-symbols-rounded">thermometer</span> Temperature Unit</h3>
        <div class="settings-option">
            <label class="radio-option">
                <input type="radio" name="temp" id="setting-celsius" checked>
                Celsius (¬∞C)
            </label>
            <label class="radio-option">
                <input type="radio" name="temp" id="setting-fahrenheit">
                Fahrenheit (¬∞F)
            </label>
        </div>
    </div>
</div>

<!-- Add this to your HTML where the other popups are -->
<div class="modal-backdrop" id="infoBackdrop"></div>
<div class="settings-popup" id="infoPopup">
    <h2>
        <span class="material-symbols-rounded">info</span>
        Welcome to the Easter Bunny's Journey Tracking website!
        <span class="settings-close" id="closeInfoBtn">
            <span class="material-symbols-rounded">close</span>
        </span>
    </h2>

    <div class="info-content">
        <p class="welcome-message">
            Hey there fellow bunny tracker! üéâ Ready to follow the Easter Bunny's magical journey around the world? Here's your quick guide to using the tracker! üó∫Ô∏è
        </p>

        <div class="guide-section">
            <h3>Map Guide</h3>
            <ul class="guide-list">
                <li>
                    <img src="https://cdn-icons-png.flaticon.com/512/7226/7226220.png" alt="Easter Bunny" class="guide-icon" />
                    Watch the Easter Bunny hop around the world in real-time! This cute icon shows where he is right now.
                </li>
                <li>
                    <img src="https://cdn-icons-png.flaticon.com/512/7226/7226674.png" alt="Unvisited Stop" class="guide-icon" />
                    <img src="https://cdn-icons-png.flaticon.com/512/7226/7226114.png" alt="Visited Stop" class="guide-icon" />
                    Spot these markers on the tracking map? They show the Easter Bunny's stops! Carrot icons are yet to visit, basket icons are already visited. Give them a click to learn more about that stop! ‚ú®
                </li>
            </ul>
        </div>

        <div class="guide-section">
            <h3>Toolbar Features</h3>
            <ul class="guide-list">
        <li>
            <span class="material-symbols-rounded">schedule</span>
            Click this icon to switch to countdown mode - where you'll see a full-screen countdown until the Easter Bunny lifts off from Easter Island! üïí
        </li>
                <li>
                    <span class="material-symbols-rounded">lock</span>
                    Want to explore? Click this to free the map from following the Easter Bunny! üó∫Ô∏è
                </li>
                <li>
                    <span class="material-symbols-rounded">settings</span>
                    Customize your experience with different units and display options! ‚öôÔ∏è
                </li>
                <li>
                    <span class="material-symbols-rounded">fullscreen</span>
                    Get the full experience - make the tracker fill your screen! üñ•Ô∏è
                </li>
            </ul>
        </div>

<p><a href="faq.html">‚ùì FAQ (Frequently Asked Questions)</a> ‚Ä¢ <a href="news.html">üì∞ Latest News</a> ‚Ä¢ <a href="chat.html">üí¨ Chat with the Easter Bunny</a>

        <div class="info-footnote">
            <a href="https://www.flaticon.com/packs/easter-197" title="Easter icon pack">
                Easter bunny icon, basket icon and carrots icon from Easter icon pack created by Freepik - Flaticon
            </a>
        </div>
    </div>
</div>

<div id="tracker">
    <div id="map"></div>
    
    <h1 class="header">üê∞ Easter Bunny's Journey Tracking üó∫Ô∏è</h1>
    
    <div class="controls">
        <button class="control-btn" onclick="toggleCountdown()">
            <span class="material-symbols-rounded">schedule</span>
        </button>
        <button class="control-btn" onclick="toggleFullscreen()">
            <span class="material-symbols-rounded">fullscreen</span>
        </button>
        <button class="control-btn" onclick="toggleSettings()">
            <span class="material-symbols-rounded">settings</span>
        </button>
        <button class="control-btn" onclick="toggleInfo()">
            <span class="material-symbols-rounded">info</span>
        </button>
<button class="control-btn lock-btn" onclick="toggleLock(this)">
    <span class="material-symbols-rounded">lock</span>
</button>
    </div>

<div class="stats-container">

<div class="stat-item stop-details-card">

    <div class="last-seen-section">
        <div class="stat-label" id="lastSeenLabel"><span class="material-symbols-rounded">history</span>Last seen</div>
        <div class="stat-value" id="lastSeenValue">Loading...</div>
    </div>

    <div class="stop-content">
        <div class="stop-header">
            <div class="stat-label" id="currentStopLabel">
                <span class="material-symbols-rounded">location_on</span> Current stop
            </div>
            <div class="stat-value" id="currentStopValue">Finding the Easter Bunny...</div>
        </div>

        <div class="depart-info">
            <div class="stat-label" id="departingLabel">
                <span class="material-icons">flight_takeoff</span> Departing in
            </div>
            <div class="stat-value" id="departingValue">Loading</div>
        </div>
    </div>
</div>
<div class="stat-item presents-cookies">
    <div class="presents-section">
        <div class="stat-label" id="presentsLabel">
<img src="https://cdn-icons-png.flaticon.com/512/7226/7226114.png" alt="üß∫" class="icon-img"/> Baskets delivered
        </div>
        <div class="stat-value" id="presentsValue">0</div>
    </div>
    <div class="cookies-section">
        <div class="stat-label" id="cookiesLabel"><img src="https://cdn-icons-png.flaticon.com/512/7226/7226674.png" alt="ü•ï" class="icon-img"/> Carrots eaten</div>
        <div class="stat-value" id="cookiesValue">0</div>
    </div>
</div>
    <div class="stat-item status-stat">
        <div class="stat-label" id="statusLabel">
            <span class="material-symbols-rounded">chat</span> Current Easter Island status
        </div>
        <div class="stat-value" id="statusValue">Loading...</div>
    </div>
<div class="stat-item arrival-stat">
    <div class="stat-label" id="arrivalLabel">
        <span class="material-symbols-rounded">access_time_filled</span> Arrival
    </div>
    <div class="stat-value" id="arrivalValue">Calculating...</div>
</div>
<div class="stat-item extra-stats">
    <div class="distance-section">
        <div class="stat-label" id="distanceLabel">
            <span class="material-symbols-rounded">route</span> Distance travelled
        </div>
        <div class="stat-value" id="distanceValue">0 km</div>
    </div>
    <div class="speed-section">
        <div class="stat-label" id="speedLabel"><span class="material-symbols-rounded">speed</span>Current hop speed</div>
        <div class="stat-value" id="currentSpeedValue">0 km/h</div>
    </div>

        <!-- Add the new time zone section here! -->
        <div class="timezone-section">
            <div class="stat-label" id="timezoneLabel">
                <span class="material-symbols-rounded">schedule</span> Current time
            </div>
            <div class="stat-value" id="timezoneValue">Loading...</div>
        </div>

    <div class="weather-section">
        <div class="stat-label" id="weatherLabel"><span class="material-symbols-rounded">thermostat</span>Weather</div>
        <div class="stat-value" id="weatherValue">Loading...</div>
    </div>
</div>
</div>

<div class="stats-container-mobile">
    <!-- Current/Next Stop Section -->
    <div class="mobile-header-section">
        <div class="mobile-stop-info">
            <div class="mobile-stop-label" id="currentStopLabel-mobile">
                <span class="material-symbols-rounded">location_on</span>
                <span class="label-text">Current stop</span>
            </div>
            <div class="mobile-stop-value" id="currentStopValue-mobile">Finding the Easter Bunny...</div>
        </div>
        
        <div class="mobile-meta-info">
            <div class="mobile-time-weather">
                <span class="material-symbols-rounded">schedule</span>
                <span id="timezoneValue-mobile">Loading...</span>
                <span class="divider">‚Ä¢</span>
                <span class="material-symbols-rounded">thermostat</span>
                <span id="weatherValue-mobile">Loading...</span>
                <span class="divider">‚Ä¢</span>
                <span class="mobile-arrival-status">
                    <span id="departingLabel-mobile" class="material-icons">flight_takeoff</span>
                    <span id="departingValue-mobile">Loading...</span>
                </span>
            </div>
<div class="meta-info-mobile">
    <span class="material-symbols-rounded" id="metaIcon-mobile">history</span>
    <span class="meta-label-mobile" id="metaLabel-mobile">Last seen:</span>
    <span id="metaValue-mobile">-</span>
</div>
        </div>
    </div>

    <!-- Stats Section -->
    <div class="mobile-stats-section">
        <div class="mobile-stats-grid">
            <div class="mobile-stat">
                <img src="https://cdn-icons-png.flaticon.com/512/7226/7226114.png" alt="üß∫" class="mobile-icon">
                <span id="presentsValue-mobile">0</span>
            </div>
            <div class="mobile-stat">
                <img src="https://cdn-icons-png.flaticon.com/512/7226/7226674.png" alt="ü•ï" class="mobile-icon">
                <span id="cookiesValue-mobile">0</span>
            </div>
            <div class="mobile-stat">
                <span class="material-symbols-rounded">route</span>
                <span id="distanceValue-mobile">0 km</span>
            </div>
            <div class="mobile-stat">
                <span class="material-symbols-rounded">speed</span>
                <span id="currentSpeedValue-mobile">0 km/h</span>
            </div>
        </div>
    </div>

    <!-- Arrival Section -->
    <div class="mobile-arrival-section" id="arrivalSection-mobile">
        <span class="material-symbols-rounded">access_time_filled</span>
        <span id="arrivalValue-mobile" class="clickable">üîç Click here to reveal when the Easter Bunny will arrive! üê∞</span>
    </div>
</div>

</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
// First, declare our variables
let settings = {
    metrics: {
        locationInfo: true,
        deliveryStats: true,
        islandStatus: true,
        arrivalTime: true,
        additionalStats: true
    },
    units: 'imperial',
    temperature: 'celsius',
    darkMode: false
};

let lightTileLayer, darkTileLayer, currentTileLayer, map, bunnyMarker;
let isMapLocked = true; // Moved this declaration up

// Create a custom Easter Bunny icon üê∞
const bunnyIcon = L.icon({
    iconUrl: 'https://cdn-icons-png.flaticon.com/512/7226/7226220.png',
    iconSize: [64, 64],
    iconAnchor: [32, 32],
    popupAnchor: [0, -32],
    className: 'bunny-marker'
});

// Initialize map function
function initializeMap() {
    // Initialize the map with a nice spring-themed style üó∫Ô∏è
    map = L.map('map', {
        dragging: false,
        touchZoom: false,
        doubleClickZoom: false,
        scrollWheelZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomControl: true
    }).setView([0, 0], 10);

    // Initialize both tile layers üåì
    lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
    });

    darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors, ¬© CARTO'
    });

    // Set initial tile layer based on settings
    currentTileLayer = settings.darkMode ? darkTileLayer : lightTileLayer;
    currentTileLayer.addTo(map);

    // Add the Easter Bunny marker at Easter Island üóø
    bunnyMarker = L.marker([-27.1044228, -109.2489683], {
        icon: bunnyIcon,
        zIndexOffset: 1000000
    }).addTo(map);

    // Initial map view centered on Easter Bunny
    map.setView(bunnyMarker.getLatLng(), 10);

    // Disable tap if it exists
    if (map.tap) map.tap.disable();
}

// First, modify loadSettings to only set the theme without touching the map
function loadSettings() {
    const savedSettings = localStorage.getItem('bunnyTrackerSettings');
    if (savedSettings) {
        settings = JSON.parse(savedSettings);
        // Only set the document theme attribute here
        if (settings.darkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
        }
    }
}
// Helper function to get flag emoji for a region üéå
function getRegionFlag(region) {
    // Special case for Easter Island
    if (region === "Easter Island, Chile") return 'üóø';

    // Special case for undefined or empty string
    if (!region) return 'üåç';
    
    // Extract country from region if it contains a comma
    const countryMatch = region.match(/, ([^,]+)$/);
    const country = countryMatch ? countryMatch[1] : region;
    
    // Direct region/country to flag mappings
    const regionFlags = {
        // ISS stop
        'Low Earth Orbit': 'üõ∞Ô∏è',
        // Pacific Islands and Territories
        'Kiribati': 'üá∞üáÆ',
        'Tuvalu': 'üáπüáª',
        'Tokelau': 'üáπüá∞',
        'Samoa': 'üáºüá∏',
        'American Samoa': 'üá¶üá∏',
        'Wallis and Futuna': 'üáºüá´',
        'Fiji': 'üá´üáØ',
        'Tonga': 'üáπüá¥',
        'New Zealand': 'üá≥üáø',
        'Antarctica': 'üá¶üá∂',
        'Marshall Islands': 'üá≤üá≠',
        'Vanuatu': 'üáªüá∫',
        'New Caledonia': 'üá≥üá®',
        'Norfolk Island': 'üá≥üá´',
        'Solomon Islands': 'üá∏üáß',
        'Nauru': 'üá≥üá∑',
        'Micronesia': 'üá´üá≤',
        'Kuril Islands': 'üá∑üá∫',
        'Northern Mariana Islands': 'üá≤üáµ',
        'Guam': 'üá¨üá∫',
        'Papua New Guinea': 'üáµüá¨',
        'Pitcairn Islands': 'üáµüá≥',
        'Niue': 'üá≥üá∫',
        'Cook Islands': 'üá®üá∞',
        'French Polynesia': 'üáµüá´',

        // Special Administrative Regions
        'Macau': 'üá≤üá¥',
        'Hong Kong': 'üá≠üá∞',
        'Taiwan': 'üáπüáº',

        // Special Territories and Regions
        'Crimea': 'üåç',
        'Kosovo': 'üáΩüá∞',
        'Vatican City': 'üáªüá¶',
        'T√ºrkiye': 'üáπüá∑',
        'Myanmar (Burma)': 'üá≤üá≤',
        'British Indian Ocean Territory': 'üáÆüá¥',
        'French Southern and Antarctic Lands': 'üáπüá´',
        'Cocos (Keeling) Islands': 'üá®üá®',
        'Christmas Island': 'üá®üáΩ',
        'Palestine': 'üáµüá∏',
        'Timor-Leste': 'üáπüá±',
        'Svalbard and Jan Mayen': 'üá≥üá¥',
        'Azores': 'üáµüáπ',
        'Madeira': 'üáµüáπ',
        'Canary Islands': 'üá™üá∏',
        'Gibraltar': 'üá¨üáÆ',
        'Isle of Man': 'üáÆüá≤',
        'Jersey': 'üáØüá™',
        'Guernsey': 'üá¨üá¨',
        'Faroe Islands': 'üá´üá¥',
        'Greenland': 'üá¨üá±',
        'Saint Helena, Ascension and Tristan da Cunha': 'üá∏üá≠',
        'South Georgia and the South Sandwich Islands': 'üá¨üá∏',
        'Falkland Islands (Islas Malvinas)': 'üá´üá∞',
        'R√©union': 'üá∑üá™',
        'Mayotte': 'üáæüáπ',
        'Saint Pierre and Miquelon': 'üáµüá≤',
        'Martinique': 'üá≤üá∂',
        'Guadeloupe': 'üá¨üáµ',
        'French Guiana': 'üá¨üá´',
        'Aruba': 'üá¶üáº',
        'Cura√ßao': 'üá®üáº',
        'Sint Maarten': 'üá∏üáΩ',
        'Saint Martin': 'üá≤üá´',
        'Anguilla': 'üá¶üáÆ',
        'Montserrat': 'üá≤üá∏',
        'Turks and Caicos Islands': 'üáπüá®',
        'Cayman Islands': 'üá∞üáæ',
        'Bermuda': 'üáßüá≤',
        'British Virgin Islands': 'üáªüá¨',
        'United States Virgin Islands': 'üáªüáÆ',
        'Puerto Rico': 'üáµüá∑',
        'Galapagos Islands, Ecuador': 'üá™üá®',
        'CDMX, Mexico': 'üá≤üáΩ',
        'Sicily, Italy': 'üáÆüáπ',

        // Independent Nations
        'Russia': 'üá∑üá∫',
        'Japan': 'üáØüáµ',
        'China': 'üá®üá≥',
        'South Korea': 'üá∞üá∑',
        'North Korea': 'üá∞üáµ',
        'Mongolia': 'üá≤üá≥',
        'Vietnam': 'üáªüá≥',
        'Cambodia': 'üá∞üá≠',
        'Laos': 'üá±üá¶',
        'Thailand': 'üáπüá≠',
        'Myanmar': 'üá≤üá≤',
        'Malaysia': 'üá≤üáæ',
        'Brunei': 'üáßüá≥',
        'Singapore': 'üá∏üá¨',
        'Indonesia': 'üáÆüá©',
        'Philippines': 'üáµüá≠',
        'Bhutan': 'üáßüáπ',
        'Nepal': 'üá≥üáµ',
        'Bangladesh': 'üáßüá©',
        'India': 'üáÆüá≥',
        'Sri Lanka': 'üá±üá∞',
        'Maldives': 'üá≤üáª',
        'Pakistan': 'üáµüá∞',
        'Afghanistan': 'üá¶üá´',
        'Iran': 'üáÆüá∑',
        'Iraq': 'üáÆüá∂',
        'Saudi Arabia': 'üá∏üá¶',
        'Kuwait': 'üá∞üáº',
        'Bahrain': 'üáßüá≠',
        'Qatar': 'üá∂üá¶',
        'United Arab Emirates': 'üá¶üá™',
        'Oman': 'üá¥üá≤',
        'Yemen': 'üáæüá™',
        'Jordan': 'üáØüá¥',
        'Lebanon': 'üá±üáß',
        'Syria': 'üá∏üáæ',
        'Israel': 'üáÆüá±',
        'Cyprus': 'üá®üáæ',
        'Turkey': 'üáπüá∑',
        'Greece': 'üá¨üá∑',
        'Bulgaria': 'üáßüá¨',
        'Romania': 'üá∑üá¥',
        'Moldova': 'üá≤üá©',
        'Ukraine': 'üá∫üá¶',
        'Belarus': 'üáßüáæ',
        'Lithuania': 'üá±üáπ',
        'Latvia': 'üá±üáª',
        'Estonia': 'üá™üá™',
        'Finland': 'üá´üáÆ',
        'Sweden': 'üá∏üá™',
        'Norway': 'üá≥üá¥',
        'Denmark': 'üá©üá∞',
        'Iceland': 'üáÆüá∏',
        'Ireland': 'üáÆüá™',
        'United Kingdom': 'üá¨üáß',
        'Portugal': 'üáµüáπ',
        'Spain': 'üá™üá∏',
        'France': 'üá´üá∑',
        'Belgium': 'üáßüá™',
        'Netherlands': 'üá≥üá±',
        'Germany': 'üá©üá™',
        'Poland': 'üáµüá±',
        'Czechia': 'üá®üáø',
        'Slovakia': 'üá∏üá∞',
        'Hungary': 'üá≠üá∫',
        'Austria': 'üá¶üáπ',
        'Switzerland': 'üá®üá≠',
        'Liechtenstein': 'üá±üáÆ',
        'Slovenia': 'üá∏üáÆ',
        'Croatia': 'üá≠üá∑',
        'Bosnia and Herzegovina': 'üáßüá¶',
        'Serbia': 'üá∑üá∏',
        'Montenegro': 'üá≤üá™',
        'North Macedonia': 'üá≤üá∞',
        'Albania': 'üá¶üá±',
        'Italy': 'üáÆüáπ',
        'San Marino': 'üá∏üá≤',
        'Malta': 'üá≤üáπ',
        'Kazakhstan': 'üá∞üáø',
        'Kyrgyzstan': 'üá∞üá¨',
        'Tajikistan': 'üáπüáØ',
        'Turkmenistan': 'üáπüá≤',
        'Uzbekistan': 'üá∫üáø',
        'Georgia': 'üá¨üá™',
        'Armenia': 'üá¶üá≤',
        'Azerbaijan': 'üá¶üáø',
        'Egypt': 'üá™üá¨',
        'Libya': 'üá±üáæ',
        'Tunisia': 'üáπüá≥',
        'Algeria': 'üá©üáø',
        'Morocco': 'üá≤üá¶',
        'Western Sahara': 'üá™üá≠',
        'Mauritania': 'üá≤üá∑',
        'Mali': 'üá≤üá±',
        'Niger': 'üá≥üá™',
        'Chad': 'üáπüá©',
        'Sudan': 'üá∏üá©',
        'South Sudan': 'üá∏üá∏',
        'Eritrea': 'üá™üá∑',
        'Ethiopia': 'üá™üáπ',
        'Djibouti': 'üá©üáØ',
        'Somalia': 'üá∏üá¥',
        'Kenya': 'üá∞üá™',
        'Uganda': 'üá∫üá¨',
        'Rwanda': 'üá∑üáº',
        'Burundi': 'üáßüáÆ',
        'Tanzania': 'üáπüáø',
        'Mozambique': 'üá≤üáø',
        'Malawi': 'üá≤üáº',
        'Madagascar': 'üá≤üá¨',
        'Comoros': 'üá∞üá≤',
        'Seychelles': 'üá∏üá®',
        'Mauritius': 'üá≤üá∫',
        'Zimbabwe': 'üáøüáº',
        'Zambia': 'üáøüá≤',
        'Angola': 'üá¶üá¥',
        'Democratic Republic of the Congo': 'üá®üá©',
        'Congo (Republic)': 'üá®üá¨',
        'Gabon': 'üá¨üá¶',
        'Equatorial Guinea': 'üá¨üá∂',
        'S√£o Tom√© and Pr√≠ncipe': 'üá∏üáπ',
        'Cameroon': 'üá®üá≤',
        'Nigeria': 'üá≥üá¨',
        'Benin': 'üáßüáØ',
        'Togo': 'üáπüá¨',
        'Ghana': 'üá¨üá≠',
        'Burkina Faso': 'üáßüá´',
        'C√¥te d\'Ivoire': 'üá®üáÆ',
        'Liberia': 'üá±üá∑',
        'Sierra Leone': 'üá∏üá±',
        'Guinea': 'üá¨üá≥',
        'Guinea-Bissau': 'üá¨üáº',
        'Senegal': 'üá∏üá≥',
        'The Gambia': 'üá¨üá≤',
        'Cabo Verde': 'üá®üáª',
        'Central African Republic': 'üá®üá´',
        'South Africa': 'üáøüá¶',
        'Namibia': 'üá≥üá¶',
        'Botswana': 'üáßüáº',
        'Eswatini': 'üá∏üáø',
        'Lesotho': 'üá±üá∏',

        // Americas
        'Canada': 'üá®üá¶',
        'United States': 'üá∫üá∏',
        'Mexico': 'üá≤üáΩ',
        'Belize': 'üáßüáø',
        'Guatemala': 'üá¨üáπ',
        'El Salvador': 'üá∏üáª',
        'Honduras': 'üá≠üá≥',
        'Nicaragua': 'üá≥üáÆ',
        'Costa Rica': 'üá®üá∑',
        'Panama': 'üáµüá¶',
        'Colombia': 'üá®üá¥',
        'Venezuela': 'üáªüá™',
        'Guyana': 'üá¨üáæ',
        'Suriname': 'üá∏üá∑',
        'Brazil': 'üáßüá∑',
        'Ecuador': 'üá™üá®',
        'Peru': 'üáµüá™',
        'Bolivia': 'üáßüá¥',
        'Paraguay': 'üáµüáæ',
        'Chile': 'üá®üá±',
        'Argentina': 'üá¶üá∑',
        'Uruguay': 'üá∫üáæ',
        'Trinidad and Tobago': 'üáπüáπ',
        'Grenada': 'üá¨üá©',
        'Saint Vincent and the Grenadines': 'üáªüá®',
        'Saint Lucia': 'üá±üá®',
        'Barbados': 'üáßüáß',
        'Dominica': 'üá©üá≤',
        'Antigua and Barbuda': 'üá¶üá¨',
        'Saint Kitts and Nevis': 'üá∞üá≥',
        'Saint Barth√©lemy': 'üáßüá±',
        'Haiti': 'üá≠üáπ',
        'Dominican Republic': 'üá©üá¥',
        'Jamaica': 'üáØüá≤',
        'Cuba': 'üá®üá∫',
        'The Bahamas': 'üáßüá∏'
    };

    // Handle special cases for states/regions
    if (region.includes(', ')) {
        const [state, country] = region.split(', ');
        // Return the country flag for states/regions
        return regionFlags[country] || regionFlags[region] || 'üìç';
    }

    // Return the flag for the region/country or fallback to globe
    return regionFlags[region] || 'üìç';
}

// Helper function to calculate distance between two points using Haversine formula
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
             Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
             Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Add these variables at the top of your script with other global variables
let totalDistance = 0;
let lastPosition = null;
let distanceInitialized = false;

// Add this function to calculate initial distance
function initializeDistance(now) {
    if (distanceInitialized) return;
    
    totalDistance = 0;
    const { easterEveDate } = getEasterDates();
    const easterEveStart = new Date(easterEveDate);
    easterEveStart.setUTCHours(10, 0, 0, 0);

    // If journey hasn't started, set to 0
    if (now < easterEveStart) {
        totalDistance = 0;
        distanceInitialized = true;
        return;
    }

    // Calculate distance up to current point
    let lastStopPos = [-27.1044228, -109.2489683]; // Easter Island starting point
    
    for (const stop of routeData) {
        const stopTime = new Date(stop.arrival * 1000);
        if (stopTime > now) break;
        
        const stopPos = [parseFloat(stop.Latitude), parseFloat(stop.Longitude)];
        totalDistance += calculateDistance(
            lastStopPos[0], lastStopPos[1],
            stopPos[0], stopPos[1]
        );
        lastStopPos = stopPos;
    }

    // Find current position if in transit
    const currentStop = routeData.find(stop => 
        now >= new Date(stop.arrival * 1000) && 
        now < new Date(stop.departure * 1000)
    );

    if (!currentStop) {
        const lastStop = [...routeData]
            .filter(stop => now >= new Date(stop.departure * 1000))
            .sort((a, b) => b.departure - a.departure)[0];
        
        const nextStop = [...routeData]
            .filter(stop => now < new Date(stop.arrival * 1000))
            .sort((a, b) => a.arrival - b.arrival)[0];

        if (lastStop && nextStop) {
            const timeProgress = (now - lastStop.departure * 1000) / 
                               (nextStop.arrival * 1000 - lastStop.departure * 1000);
            
            const currentLat = parseFloat(lastStop.Latitude) + 
                             (timeProgress * (parseFloat(nextStop.Latitude) - parseFloat(lastStop.Latitude)));
            const currentLng = parseFloat(lastStop.Longitude) + 
                             (timeProgress * (parseFloat(nextStop.Longitude) - parseFloat(lastStop.Longitude)));
            
            totalDistance += calculateDistance(
                lastStopPos[0], lastStopPos[1],
                currentLat, currentLng
            );
        }
    }

    distanceInitialized = true;
    lastPosition = lastStopPos;
    updateDistanceDisplay(totalDistance);
    console.log(`üõ£Ô∏è [${now.toISOString().replace('T', ' ').slice(0, 19)}] Initial distance calculated:`, formatNumber(totalDistance), 'km');
}


// Update the display functions to handle imperial units
function updateDistanceDisplay(distance) {
    const distanceValue = document.getElementById('distanceValue');
    if (distanceValue) {
        let displayDistance = distance;
        let unit = 'km';
        
        if (settings.units === 'imperial') {
            displayDistance = distance * 0.621371; // Convert km to miles
            unit = 'miles';
        }
        
        const formattedDistance = Math.round(displayDistance).toLocaleString();
        distanceValue.textContent = `${formattedDistance} ${unit}`;
    }
}

// Add these variables at the top with other global variables
let speedBuffer = []; // Store recent positions and timestamps
const SPEED_BUFFER_SIZE = 5; // Number of recent positions to use for speed calculation

// Add this function to calculate current speed
function calculateCurrentSpeed(newLat, newLon, timestamp) {
    // Add new position to buffer
    speedBuffer.push({
        lat: newLat,
        lon: newLon,
        timestamp: timestamp
    });

    // Keep buffer at desired size
    if (speedBuffer.length > SPEED_BUFFER_SIZE) {
        speedBuffer.shift();
    }

    // Need at least 2 points to calculate speed
    if (speedBuffer.length < 2) {
        return 0;
    }

    // Calculate speed using the most recent positions
    const oldest = speedBuffer[0];
    const newest = speedBuffer[speedBuffer.length - 1];
    
    // Calculate distance in km
    const distance = calculateDistance(
        oldest.lat, oldest.lon,
        newest.lat, newest.lon
    );

    // Calculate time difference in hours
    const timeDiff = (newest.timestamp - oldest.timestamp) / (1000 * 60 * 60);

    // Calculate speed in km/h
    return distance / timeDiff;
}

// Add this function to update the speed display
function updateSpeedDisplay(speed) {
    const speedValue = document.getElementById('currentSpeedValue');
    if (speedValue) {
        let displaySpeed = speed;
        let unit = 'km/h';
        
        if (settings.units === 'imperial') {
            displaySpeed = speed * 0.621371; // Convert km/h to mph
            unit = 'mph';
        }
        
        const formattedSpeed = Math.round(displaySpeed).toLocaleString();
        speedValue.textContent = `${formattedSpeed} ${unit}`;
    }
}

// Function to fetch and update weather
async function updateWeather(latitude, longitude) {
    try {
        const now = getCurrentDateTime();
        const formattedTime = now.toISOString().replace('T', ' ').slice(0, 19);

        // Add temperature unit parameter based on settings
        const useFahrenheit = settings.temperature === 'fahrenheit';
        const temperatureParam = useFahrenheit ? '&temperature_unit=fahrenheit' : '';
        
        const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true${temperatureParam}`);
        const data = await response.json();

        const weatherValue = document.getElementById('weatherValue');
        if (weatherValue && data.current_weather) {
            const temperature = data.current_weather.temperature;
            const unit = data.current_weather_units.temperature;
            weatherValue.textContent = `${temperature}${unit}`;
           
        }
    } catch (error) {
        console.error(`‚ùå [${getCurrentDateTime().toISOString().replace('T', ' ').slice(0, 19)}] Weather update error:`, error);
    }
}

// Add these variables at the top with other global variables
let preTrackingData = null;
let lastPreTrackingUpdate = null;

// Function to fetch pre-tracking data
async function fetchPreTrackingData() {
  try {
    const response = await fetch('https://api.npoint.io/6412ce8ae90f2330f538');
    const data = await response.json();
    preTrackingData = data.easter_bunny_pre_tracking_updates.sort((a, b) => 
      new Date(b.timestamp) - new Date(a.timestamp)
    );
    console.log('üéØ Pre-tracking data loaded:', preTrackingData.length, 'updates');
  } catch (error) {
    console.error('‚ùå Error fetching pre-tracking data:', error);
  }
}


// Function to check if we're in pre-tracking time
function isPreTrackingTime(now) {
    const { easterEveDate } = getEasterDates();
    const trackingStart = new Date(easterEveDate);
    trackingStart.setUTCHours(8, 30, 0, 0); // 8:30 AM UTC
    
    const trackingEnd = new Date(easterEveDate);
    trackingEnd.setUTCHours(10, 0, 0, 0); // 10:00 AM UTC
    
    // Use getCurrentDateTime() for comparison
    return getCurrentDateTime() >= trackingStart && getCurrentDateTime() < trackingEnd;
}

// Function to update pre-tracking status
function updatePreTrackingStatus(now) {
    const statusStat = document.querySelector('.status-stat');
    const statusValue = document.getElementById('statusValue');

    // Get mobile meta elements
    const metaIcon = document.getElementById('metaIcon-mobile');
    const metaLabel = document.getElementById('metaLabel-mobile');
    const metaValue = document.getElementById('metaValue-mobile');
    
    // Helper function to update status text and handle size
    function updateStatusText(text) {
        statusValue.classList.toggle('long-update', text.length > 125);
        statusValue.innerHTML = text;

        // Update mobile meta info with Easter Island status
        if (metaIcon && metaLabel && metaValue) {
            metaIcon.textContent = 'history';
            metaLabel.textContent = 'Last seen:';
            metaValue.innerHTML = text;
        }
    }
    
    const { easterEveDate } = getEasterDates();
    const trackingStart = new Date(easterEveDate);
    trackingStart.setUTCHours(8, 30, 0, 0); // 8:30 AM UTC
    
    const trackingEnd = new Date(easterEveDate);
    trackingEnd.setUTCHours(10, 0, 0, 0); // 10:00 AM UTC

    // Easter Island weather updates
    const easterIslandPosition = [-27.1044228, -109.2489683];
    const currentTime = getCurrentDateTime().getTime();
    if (currentTime - lastWeatherUpdate >= WEATHER_UPDATE_INTERVAL) {
        lastWeatherUpdate = currentTime;
        updateWeather(easterIslandPosition[0], easterIslandPosition[1]);
    }

    // If tracking has ended, switch to last seen
    if (getCurrentDateTime() >= trackingEnd) {
        statusStat.style.display = 'none';
        
        // Switch mobile display to last seen
        if (metaIcon && metaLabel && metaValue) {
            metaIcon.textContent = 'history';
            metaLabel.textContent = 'Last seen:';
        }
        return;
    }

    if (statusStat) {
        statusStat.style.display = settings.metrics.islandStatus ? 'block' : 'none';
    }

    if (getCurrentDateTime() < trackingStart) {
        const countdown = Math.max(0, Math.floor((trackingStart - getCurrentDateTime()) / 1000));
        updateStatusText(`‚è≥ Pre-tracking begins in ${formatCountdown(countdown)}`);
        return;
    }

    if (!preTrackingData) {
        updateStatusText('Loading updates...');
        return;
    }

    // Adjust the timestamp comparison to use the current year
    const currentUpdate = preTrackingData.find(update => {
        const updateDate = new Date(update.timestamp);
        const currentDate = getCurrentDateTime();
        
        // Create a new date using current year but keeping month/day/time from the update
        const adjustedUpdateDate = new Date(
            currentDate.getFullYear(),
            updateDate.getMonth(),
            updateDate.getDate(),
            updateDate.getUTCHours(),
            updateDate.getUTCMinutes(),
            updateDate.getUTCSeconds()
        );
        
        return currentDate >= adjustedUpdateDate;
    });

    if (!currentUpdate) {
        updateStatusText('Waiting for updates...');
        return;
    }

    const originalOrder = [...preTrackingData].sort((a, b) => 
        new Date(a.timestamp) - new Date(b.timestamp)
    );
    const currentIndex = originalOrder.findIndex(u => u.timestamp === currentUpdate.timestamp);
    const nextUpdate = originalOrder[currentIndex + 1];

    if (!lastPreTrackingUpdate || lastPreTrackingUpdate.timestamp !== currentUpdate.timestamp) {
        console.log(`üîÑ [${getCurrentDateTime().toISOString().replace('T', ' ').slice(0, 19)}] Pre-tracking Update:`, {
            update: currentUpdate.update,
            timestamp: currentUpdate.timestamp
        });
        lastPreTrackingUpdate = currentUpdate;
    }

    if (nextUpdate) {
        // Adjust next update timestamp to current year
        const nextUpdateDate = new Date(nextUpdate.timestamp);
        const currentDate = getCurrentDateTime();
        const adjustedNextUpdate = new Date(
            currentDate.getFullYear(),
            nextUpdateDate.getMonth(),
            nextUpdateDate.getDate(),
            nextUpdateDate.getUTCHours(),
            nextUpdateDate.getUTCMinutes(),
            nextUpdateDate.getUTCSeconds()
        );
        
        const countdown = Math.max(0, Math.floor((adjustedNextUpdate - getCurrentDateTime()) / 1000));
        updateStatusText(`${currentUpdate.update}<br><small>Next update in: ${formatCountdown(countdown)}</small>`);
    } else {
        updateStatusText(currentUpdate.update);
    }
}

// Major Cities Worldwide üåé
const TEST_LOCATIONS = {
    // Americas
    newYork: { lat: 40.7128, lng: -74.0060 },      // New York City, USA üóΩ
    losAngeles: { lat: 34.0522, lng: -118.2437 },  // Los Angeles, USA üå¥
    toronto: { lat: 43.6532, lng: -79.3832 },      // Toronto, Canada üçÅ
    rioDeJaneiro: { lat: -22.9068, lng: -43.1729 }, // Rio de Janeiro, Brazil üèñÔ∏è
    
    // Europe
    london: { lat: 51.5074, lng: -0.1278 },        // London, UK üá¨üáß
    paris: { lat: 48.8566, lng: 2.3522 },          // Paris, France üóº
    rome: { lat: 41.9028, lng: 12.4964 },          // Rome, Italy üèõÔ∏è
    moscow: { lat: 55.7558, lng: 37.6173 },        // Moscow, Russia üè∞
    
    // Asia/Pacific
    tokyo: { lat: 35.6762, lng: 139.6503 },        // Tokyo, Japan üóº
    sydney: { lat: -33.8688, lng: 151.2093 },      // Sydney, Australia ü¶ò
    singapore: { lat: 1.3521, lng: 103.8198 },     // Singapore üåÜ
    dubai: { lat: 25.2048, lng: 55.2708 },         // Dubai, UAE üåá
    
    // Interesting Edge Cases üéØ
    rapa_nui: { lat: -27.1044228, lng: -109.2489683 }, // Easter Island itself! üóø
    honolulu: { lat: 21.3069, lng: -157.8583 },    // Honolulu - Pacific crossing test üå∫
    anchorage: { lat: 61.2181, lng: -149.9003 },   // Anchorage - Far north test ‚ùÑÔ∏è
    wellington: { lat: -41.2924, lng: 174.7787 },   // Wellington, NZ - Far south test ü•ù
    
    // Remote Locations üèùÔ∏è
    midway: { lat: 28.2072, lng: -177.3735 },      // Midway Atoll - Remote Pacific
    svalbard: { lat: 78.2232, lng: 15.6267 },      // Svalbard - Arctic Circle
    reunion: { lat: -21.1151, lng: 55.5364 },      // R√©union Island - Indian Ocean
    easter: { lat: -27.1044228, lng: -109.2489683 },  // Easter Island
    // Remote Cities & Villages üèòÔ∏è
    ushuaia: { lat: -54.8019, lng: -68.3030 },     // Ushuaia, Argentina - Southernmost city üèîÔ∏è
    longyearbyen: { lat: 78.2232, lng: 15.6267 },  // Longyearbyen, Svalbard - Northernmost town ‚ùÑÔ∏è
    iqaluit: { lat: -63.7467, lng: -68.5170 },     // Iqaluit, Nunavut, Canada - Remote arctic üå®Ô∏è
    adamstown: { lat: -25.0661, lng: -130.1015 },  // Adamstown, Pitcairn Islands - Tiny population üèùÔ∏è
    
    // Small Villages üè°
    grise_fiord: { lat: 76.4183, lng: -82.8951 },  // Grise Fiord, Canada - Northernmost community in Americas ‚ùÑÔ∏è
    oymyakon: { lat: 63.4620, lng: 142.7866 },     // Oymyakon, Russia - Coldest inhabited place ü•∂
    whittier: { lat: 60.7730, lng: -148.6838 },    // Whittier, Alaska - Entire town in one building! üè¢
    coober_pedy: { lat: -29.0135, lng: 134.7544 }, // Coober Pedy, Australia - Underground town ‚õèÔ∏è
    
    // Remote Islands üèùÔ∏è
    tristan: { lat: -37.1052, lng: -12.2777 },     // Tristan da Cunha - Most remote inhabited island
    bouvet: { lat: -54.4208, lng: 3.3464 },        // Bouvet Island - Uninhabited remote island
    kerguelen: { lat: -49.3500, lng: 70.2167 },    // Kerguelen Islands - French Southern Territories
    baker_island: { lat: 0.1936, lng: -176.4786 }, // Baker Island - Uninhabited US territory
    
    // Desert Communities üèúÔ∏è
    timbuktu: { lat: 16.7666, lng: -3.0026 },      // Timbuktu, Mali - Ancient Saharan city
    alice_springs: { lat: -23.6980, lng: 133.8807 },// Alice Springs, Australia - Outback town
    dunhuang: { lat: 40.1130, lng: 94.6618 },      // Dunhuang, China - Gobi Desert oasis
    wahat: { lat: 29.2097, lng: 26.5890 },         // Al Wahat, Egypt - Desert oasis

    // Mountain Villages üèîÔ∏è
    la_rinconada: { lat: -14.6306, lng: -69.4459 }, // La Rinconada, Peru - Highest city
    namche_bazaar: { lat: 27.8069, lng: 86.7140 }, // Namche Bazaar, Nepal - Sherpa capital
    murren: { lat: 46.5590, lng: 7.8926 },         // M√ºrren, Switzerland - Car-free mountain village
    zermatt: { lat: 46.0207, lng: 7.7491 },        // Zermatt, Switzerland - Under the Matterhorn

    // Jungle Settlements üå¥
    manaus: { lat: -3.1190, lng: -60.0217 },       // Manaus, Brazil - Amazon rainforest
    iquitos: { lat: -3.7437, lng: -73.2516 },      // Iquitos, Peru - Largest isolated city
    palangkaraya: { lat: -2.2161, lng: 113.9135 }, // Palangkaraya, Indonesia - Borneo jungle
    rurrenabaque: { lat: -14.4412, lng: -67.5278 }, // Rurrenabaque, Bolivia - Amazon gateway

    // Tiny Island Communities üå∫
    palm_island: { lat: -18.7499, lng: 146.5872 }, // Palm Island, Australia
    niue: { lat: -19.0544, lng: -169.8672 },       // Niue - Coral atoll nation
    tokelau: { lat: -9.2002, lng: -171.8484 },     // Tokelau - New Zealand territory
    pitcairn: { lat: -25.0677, lng: -130.1002 },   // Pitcairn Islands

    // Remote Arctic/Antarctic Research Stations ‚ùÑÔ∏è
    mcmurdo: { lat: -77.8419, lng: 166.6863 },     // McMurdo Station, Antarctica
    vostok: { lat: -78.4645, lng: 106.8342 },      // Vostok Station, Antarctica
    alert: { lat: 82.5018, lng: -62.3481 },        // Alert, Nunavut - Northernmost settlement
    eureka: { lat: 79.9894, lng: -85.9408 },       // Eureka, Nunavut - Research station

    // Remote Continental Points üó∫Ô∏è
    cape_york: { lat: -10.6841, lng: 142.5278 },   // Cape York, Australia - Northernmost point
    point_nemo: { lat: -48.8767, lng: -123.3933 }, // Point Nemo - Oceanic pole of inaccessibility
    ittoqqortoormiit: { lat: 70.4833, lng: -21.9667 }, // Ittoqqortoormiit, Greenland
    barrow: { lat: 71.2906, lng: -156.7886 },      // Utqiaƒ°vik (Barrow), Alaska

    // Isolated Continental Locations üåé
    yakutsk: { lat: 62.0355, lng: 129.6755 },      // Yakutsk, Russia - Coldest major city
    norilsk: { lat: 69.3498, lng: 88.2014 },       // Norilsk, Russia - Isolated industrial city
    dabancheng: { lat: 43.3614, lng: 88.3125 },    // Dabancheng, China - Wind city
    fordlandia: { lat: -3.6619, lng: -55.497 },    // Fordlandia, Brazil - Abandoned city

    // Remote Coastal Settlements üèñÔ∏è
    barrow: { lat: 71.2906, lng: -156.7886 },      // Utqiaƒ°vik/Barrow, Alaska - Northernmost US city
    provideniya: { lat: 64.3833, lng: -173.3000 }, // Provideniya, Russia - Remote Bering Strait
    esperanza: { lat: -63.3973, lng: -56.9972 },   // Esperanza Base, Antarctica
    grytviken: { lat: -54.2811, lng: -36.5092 },   // Grytviken, South Georgia Island

    // Cultural Heritage Sites in Remote Areas üè∫
    petra: { lat: 30.3285, lng: 35.4444 },         // Petra, Jordan - Ancient city
    angkor: { lat: 13.4125, lng: 103.8670 },       // Angkor Wat, Cambodia
    machu_picchu: { lat: -13.1631, lng: -72.5450 }, // Machu Picchu, Peru
    // Space??? üöÄ
    iss: { 
        lat: -25.1162, 
        lng: -43.1948, 
        name: "International Space Station (Current) üõ∏" 
    },
};

// Add to global variables
let userLocation = null;
let nearestStop = null;
const LOCATION_TEST_MODE = true;
const TEST_COORDINATES = TEST_LOCATIONS.iss;  // Try different locations!

// Helper function to calculate distance between coordinates
function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
             Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
             Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Function to format arrival time
function formatArrivalTime(date) {
    return date.toLocaleString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
    });
}

// Function to round time to nearest quarter hour
function roundToQuarterHour(hours) {
    return Math.round(hours * 4) / 4;
}

// Function to create time range
function createTimeRange(date) {
    const minutes = date.getMinutes();
    if ([0, 10, 20, 30, 40, 50].includes(minutes)) {
        return `arriving around ${formatArrivalTime(date)};`
    }
    
    const roundDown = new Date(date);
    roundDown.setMinutes(Math.floor(minutes / 10) * 10);
    const roundUp = new Date(date);
    roundUp.setMinutes(Math.ceil(minutes / 10) * 10);
    
    return `arriving between ${roundDown.toLocaleString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} - ${roundUp.toLocaleString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })}`;
}

// Function to find nearest stop
function findNearestStop(lat, lng) {
    let nearest = null;
    let minDistance = Infinity;
    
    for (const stop of routeData) {
        const distance = calculateHaversineDistance(
            lat, lng,
            parseFloat(stop.Latitude),
            parseFloat(stop.Longitude)
        );
        
        if (distance < minDistance) {
            minDistance = distance;
            nearest = stop;
        }
    }
    
    return nearest;
}

// Function to update arrival message
function updateArrivalMessage() {
    if (!userLocation || !nearestStop) return;
    
    const now = getCurrentDateTime();
    const arrivalTime = new Date(nearestStop.arrival * 1000);
    const nextStop = [...routeData]
        .filter(stop => now < new Date(stop.arrival * 1000))
        .sort((a, b) => a.arrival - b.arrival)[0];
    
    const isNextStop = nextStop && nextStop.City === nearestStop.City;
    const arrivalValue = document.getElementById('arrivalValue');
    
    // Easter Bunny already visited
    if (now >= arrivalTime) {
        arrivalValue.innerHTML = `üéâ The Easter Bunny arrived at around ${formatArrivalTime(arrivalTime)}!`;
        return;
    }
    
    // Calculate hours until arrival
    const hoursUntil = (arrivalTime - now) / (1000 * 60 * 60);
    
    if (hoursUntil <= 1) {
        const timeRange = createTimeRange(arrivalTime);
        if (isNextStop) {
            arrivalValue.innerHTML = `üåü EGGS-CITING NEWS! The Easter Bunny is hopping straight to your area next, get ready!`;
        } else {
            arrivalValue.innerHTML = `üå∏ The Easter Bunny will arrive soon (${timeRange})`;
        }
    } else if (hoursUntil <= 48) {
        // Handle hours (original logic)
        const roundedHours = roundToQuarterHour(hoursUntil);
        const hourText = roundedHours === 1 ? 'hour' : 'hours';
        const fractionPart = roundedHours % 1;
        let timeText;
        
        if (fractionPart === 0) timeText = `${roundedHours}`;
        else if (fractionPart === 0.25) timeText = `${Math.floor(roundedHours)}¬º`;
        else if (fractionPart === 0.5) timeText = `${Math.floor(roundedHours)}¬Ω`;
        else timeText = `${Math.floor(roundedHours)}¬æ`;
        
        arrivalValue.innerHTML = `üå∏ The Easter Bunny will arrive in about ${timeText} ${hourText}`;
    } else {
        // Handle days (new logic)
        const days = Math.floor(hoursUntil / 24);
        const remainingHours = hoursUntil % 24;
        const roundedHours = roundToQuarterHour(remainingHours);
        
        if (roundedHours === 0) {
            arrivalValue.innerHTML = `üê∞ The Easter Bunny will arrive in ${days} ${days === 1 ? 'day' : 'days'}`;
        } else {
            arrivalValue.innerHTML = `üê∞ The Easter Bunny will arrive in ${days} ${days === 1 ? 'day' : 'days'} and about ${roundedHours} ${roundedHours === 1 ? 'hour' : 'hours'}`;
        }
    }
}

// Update the handleLocationAccess function to update both desktop and mobile
async function handleLocationAccess() {
    const arrivalValue = document.getElementById('arrivalValue');
    const arrivalValueMobile = document.getElementById('arrivalValue-mobile');
    
    if (LOCATION_TEST_MODE) {
        userLocation = TEST_COORDINATES;
        nearestStop = findNearestStop(userLocation.lat, userLocation.lng);
        updateArrivalMessage();
        return;
    }
    
    if (!navigator.geolocation) {
        const message = 'üì± Oops! Your browser doesn\'t support location services. Unable to estimate arrival time.';
        arrivalValue.innerHTML = message;
        arrivalValueMobile.innerHTML = message;
        return;
    }
    
    try {
        const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject);
        });
        
        userLocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
        };
        
        nearestStop = findNearestStop(userLocation.lat, userLocation.lng);
        updateArrivalMessage();
        
    } catch (error) {
        const message = error.code === 1
            ? 'üîí Location access denied. Please enable location services and try clicking again to see when the Easter Bunny will visit!'
            : '‚ùå Unable to get your location. Click to try again!';
        
        arrivalValue.innerHTML = message;
        arrivalValueMobile.innerHTML = message;
    }
}

// Add click handler to arrival value element
function initializeArrivalEstimator() {
    const arrivalValue = document.getElementById('arrivalValue');
    arrivalValue.innerHTML = 'üîç Click here to reveal when the Easter Bunny will arrive! üê∞';
    arrivalValue.style.cursor = 'pointer';
    arrivalValue.addEventListener('click', () => {
        if (!userLocation) {
            handleLocationAccess();
        }
    });
}

// Add to your initialization code
document.addEventListener('DOMContentLoaded', () => {
    initializeArrivalEstimator();
});

// Add to global variables üéØ
let destinationMarkers = new Map(); // Store markers by unique location key

// Create marker icons üé®
const markerIcons = {
    unvisited: L.icon({
        iconUrl: 'https://cdn-icons-png.flaticon.com/512/7226/7226674.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        tooltipAnchor: [0, -36]
    }),
    visited: L.icon({
        iconUrl: 'https://cdn-icons-png.flaticon.com/512/7226/7226114.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        tooltipAnchor: [0, -36]
    }),
    iss: L.icon({
        iconUrl: 'https://cdn-icons-png.flaticon.com/512/16116/16116385.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        tooltipAnchor: [0, -36]
    })
};

// Add CSS styles üé®
const styleSheet = document.createElement('style');
styleSheet.textContent = `
    .destination-tooltip {
        background-color: rgba(255, 255, 255, 0.95);
        border: 2px solid #ff69b4;
        border-radius: 12px;
        padding: 8px 12px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .leaflet-tooltip-top.destination-tooltip:before {
        border-top-color: #ff69b4;
    }
    
    /* Ensure Easter Bunny marker stays on top */
    .bunny-marker {
        z-index: 1000 !important;
    }
`;
document.head.appendChild(styleSheet);

// Helper function to safely format numbers
function formatNumberWithCommas(num) {
    if (num === undefined || num === null) {
        console.warn('Received undefined/null number to format');
        return '0';
    }
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// Helper function to safely get previous stop's baskets
function getPreviousStopBaskets(stop) {
    if (!stop || !routeData) return 0;
    
    const stopIndex = routeData.findIndex(s => 
        s.City === stop.City && 
        s.Region === stop.Region
    );
    
    if (stopIndex <= 0) return 0;
    
    const previousBaskets = routeData[stopIndex - 1].basketsDelivered;
    return previousBaskets || 0;
}


// Function to fetch Wikipedia summary with better error handling
async function fetchWikiSummary(wikiLink) {
    if (!wikiLink) {
        console.error('‚ùå No Wikipedia link provided');
        throw new Error('No Wikipedia link provided');
    }

    try {
        const searchTerm = wikiLink.split('/wiki/')[1];
        console.log(`üîç Fetching Wikipedia data for: ${searchTerm}`);
        
        const response = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${searchTerm}`);
        
        if (!response.ok) {
            throw new Error(`Wikipedia API returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log(`‚úÖ Wikipedia data fetched for: ${searchTerm}`);
        
        return {
            description: data.description || 'No description available',
            extract: (data.extract || 'No extract available'),
            fullLink: wikiLink
        };
    } catch (error) {
        console.error('‚ùå Error fetching Wikipedia summary:', error);
        throw error; // Propagate error for handling in createPopupContent
    }
}

// Function to create popup content
async function createPopupContent(stop) {
    try {
        console.log('Creating popup for stop:', stop);

        // Validate stop data
        if (!stop) throw new Error('No stop data provided');
        
        // Safely get values with defaults using correct field names
        const basketsAtStop = (stop.basketsDelivered || 0) - getPreviousStopBaskets(stop);
        const now = getCurrentDateTime();
        const arrivalTime = stop.arrival * 1000; // Don't modify for marker state check
        const population = stop['Population Num'] || 0;
        const populationYear = stop['Population Year'] || 'N/A';
        const timezone = stop.Timezone || 'UTC';
        const wikiLink = stop['Wikipedia attr'];

        // Get user's timezone
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        // Create content
        const content = document.createElement('div');
        content.innerHTML = `
            <div class="popup-header">
                ${getRegionFlag(stop.Region)} ${stop.City || 'Unknown City'}, ${stop.Region || 'Unknown Region'}
            </div>
            
            <div class="popup-stat">
                <img src="https://cdn-icons-png.flaticon.com/512/7226/7226114.png" alt="üß∫" class="icon-img"/>
                <div class="popup-stat-content">
                    <span class="popup-stat-label">${now >= arrivalTime ? 'Baskets delivered here' : 'Baskets to deliver here'}</span>
                    ${formatNumberWithCommas(basketsAtStop)}
                </div>
            </div>
            
            <div class="popup-stat">
                <span class="material-symbols-rounded">group</span>
                <div class="popup-stat-content">
                    <span class="popup-stat-label">Population</span>
                    ${formatNumberWithCommas(population)} (${populationYear})
                </div>
            </div>
            
            <div class="popup-stat">
                <span class="material-symbols-rounded">schedule</span>
                <div class="popup-stat-content">
                    <span class="popup-stat-label">${now >= arrivalTime ? 'Arrived at' : 'Arriving at'}</span>
                    Your time (${userTimezone}): ${formatDateInTimezone(stop.arrival, userTimezone)}<br>
                    Local time (${timezone}): ${formatDateInTimezone(stop.arrival, timezone)}
                </div>
            </div>`;

        // Only add Wikipedia section if URL exists
        if (wikiLink) {
            content.innerHTML += `
                <div class="popup-overview">
                    <div class="popup-description">Loading Wikipedia info...</div>
                </div>`;

            try {
                const wikiInfo = await fetchWikiSummary(wikiLink);
                const overviewDiv = content.querySelector('.popup-overview');
                overviewDiv.innerHTML = `
                    <div class="popup-description">${wikiInfo.description || 'No description available'}</div>
                    <div class="popup-extract">${wikiInfo.extract || 'No extract available'}</div>
                    <a href="${wikiLink}" target="_blank" class="popup-wiki-link">
                        Read more on Wikipedia
                        <span class="material-symbols-rounded">open_in_new</span>
                    </a>`;
            } catch (wikiError) {
                console.warn('Wikipedia fetch error:', wikiError);
                const overviewDiv = content.querySelector('.popup-overview');
                overviewDiv.innerHTML = `
                    <div class="popup-description">Wikipedia info currently unavailable</div>
                    <a href="${wikiLink}" target="_blank" class="popup-wiki-link">
                        View on Wikipedia
                        <span class="material-symbols-rounded">open_in_new</span>
                    </a>`;
            }
        }

        return content;

    } catch (error) {
        console.error('Error creating popup content:', error);
        console.log('Problematic stop data:', stop);
        
        // Return error content
        const errorContent = document.createElement('div');
        errorContent.innerHTML = `
            <div class="popup-header">
                ${stop?.Region ? getRegionFlag(stop.Region) : 'üè≥Ô∏è'} 
                ${stop?.City || 'Unknown City'}, 
                ${stop?.Region || 'Unknown Region'}
            </div>
            <div class="popup-stat">
                <span class="material-symbols-rounded">error</span>
                <div class="popup-stat-content">
                    <span class="popup-stat-label">Error Details</span>
                    An error occurred loading this stop's information
                </div>
            </div>`;
        return errorContent;
    }
}

// Helper function to format date in timezone (modified to fix UTC display)
function formatDateInTimezone(timestamp, timezone) {
    try {
        // Add one hour (3600 seconds) only for display purposes
        const adjustedTimestamp = (timestamp + 3600) * 1000;
        return new Date(adjustedTimestamp).toLocaleString('en-US', {
            timeZone: timezone || 'UTC',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
    } catch (e) {
        console.error('Error formatting date:', e, 'timestamp:', timestamp, 'timezone:', timezone);
        return 'Time unknown';
    }
}


// Function to initialize destination markers üó∫Ô∏è
async function initializeDestinationMarkers() {
    console.log('üó∫Ô∏è Starting marker initialization...');
    
    // Clear existing markers
    destinationMarkers.forEach(marker => marker.remove());
    destinationMarkers.clear();

    // Create all markers with tooltips and popups
    for (const stop of routeData) {
        if (stop.City === "Easter Bunny's Workshop") continue;

        const locationKey = `${stop.Latitude},${stop.Longitude}`;

        if (!destinationMarkers.has(locationKey)) {
            const marker = L.marker(
                [parseFloat(stop.Latitude), parseFloat(stop.Longitude)],
                { 
                    icon: markerIcons.unvisited,
                    zIndexOffset: 100
                }
            );

            // Add tooltip
            marker.bindTooltip(
                `${getRegionFlag(stop.Region)} ${stop.City}, ${stop.Region}`,
                {
                    direction: 'top',
                    permanent: false,
                    className: 'destination-tooltip'
                }
            );

            // Create initial popup with loading state
            const loadingPopup = L.popup({
                className: 'custom-popup',
                maxWidth: 300,
                minWidth: 300
            }).setContent('<div class="popup-header">Loading...</div>');

            marker.bindPopup(loadingPopup);

            // Add click handler to load content
            marker.on('click', async function() {
                if (!marker.getPopup().getContent().includes('Loading...')) {
                    return; // Content already loaded
                }
                
                console.log('üîÑ Loading popup content for:', stop.City);
                try {
                    const content = await createPopupContent(stop);
                    marker.getPopup().setContent(content);
                    marker.getPopup().update();
                    console.log('‚úÖ Popup content loaded for:', stop.City);
                } catch (error) {
                    console.error('‚ùå Error loading popup content for:', stop.City, error);
                    marker.getPopup().setContent('<div class="popup-header">Error loading content</div>');
                    marker.getPopup().update();
                }
            });

            // Add to map
            marker.addTo(map);
            destinationMarkers.set(locationKey, {
                marker: marker,
                stops: [stop]
            });
        } else {
            destinationMarkers.get(locationKey).stops.push(stop);
        }
    }

    console.log(`‚ú® All markers initialized: ${destinationMarkers.size}`);
}

// Function to update marker states üîÑ
function updateMarkerStates() {
    const now = getCurrentDateTime();

    destinationMarkers.forEach((markerData, locationKey) => {
        const { marker, stops } = markerData;
        
        // Find earliest arrival and latest departure for this location
        const earliestArrival = Math.min(...stops.map(stop => stop.arrival));
        const latestDeparture = Math.max(...stops.map(stop => stop.departure));

        // Check if the location is the International Space Station or Bunny Journey's Tracking Satelite stop
        const isISS = stops.some(stop => stop.Region === "Low Earth Orbit");

        // Determine marker state
        const hasVisited = now >= latestDeparture * 1000;
        const isCurrentlyHere = now >= earliestArrival * 1000 && now < latestDeparture * 1000;

        // Update marker appearance
        if (isCurrentlyHere) {
            // Easter Bunny is here - hide marker
            marker.setOpacity(0);
        } else if (isISS) {
            // Use ISS icon for the International Space Station
            marker.setOpacity(1);
            marker.setIcon(markerIcons.iss);
        } else if (hasVisited) {
            // Location visited - show visited icon
            marker.setOpacity(1);
            marker.setIcon(markerIcons.visited);
        } else {
            // Not visited yet - show unvisited icon
            marker.setOpacity(1);
            marker.setIcon(markerIcons.unvisited);
        }
    });
}

function getGlobeEmoji(timezone) {
    // Lists of regions for each globe emoji
    const americas = ['America', 'Argentina', 'Brazil', 'Canada', 'Chile', 'Mexico'];
    const asiaOceania = ['Asia', 'Japan', 'Singapore', 'Australia', 'Pacific', 'Indian'];
    
    // Check which region the timezone belongs to
    if (americas.some(region => timezone.includes(region))) {
        return 'üåé'; // Americas
    } else if (asiaOceania.some(region => timezone.includes(region))) {
        return 'üåè'; // Asia/Oceania
    } else {
        return 'üåç'; // Europe/Africa (default)
    }
}

function updateLocalTime() {
    try {
        const now = getCurrentDateTime();
        
        // Get current and next stops using your existing logic
        const currentStop = routeData.find(stop => 
            now >= new Date(stop.arrival * 1000) && 
            now < new Date(stop.departure * 1000)
        );
        
        const nextStop = [...routeData]
            .filter(stop => now < new Date(stop.arrival * 1000))
            .sort((a, b) => a.arrival - b.arrival)[0];

        // Get the timezone to use
        let timezone;
        if (currentStop) {
            timezone = currentStop.Timezone;
        } else if (nextStop) {
            timezone = nextStop.Timezone;
        } else {
            // Pre-journey or post-journey: Use Easter Island timezone
            timezone = "Pacific/Easter";
        }

        if (timezone) {
            let localTime, tzAbbr;

            // Try moment.js first
            if (typeof moment !== 'undefined' && moment.tz) {
                localTime = moment().tz(timezone).format('h:mm A');
                // Special case for Easter Island
                tzAbbr = timezone === "Pacific/Easter" ? "EASST" : moment().tz(timezone).format('z');
            } else {
                // Fallback to native JavaScript
                localTime = new Date().toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZone: timezone
                });

                // Special case for Easter Island
                if (timezone === "Pacific/Easter") {
                    tzAbbr = "EASST";
                } else {
                    tzAbbr = new Date().toLocaleTimeString('en-US', {
                        timeZone: timezone,
                        timeZoneName: 'short'
                    }).split(' ').pop();
                }
            }
            
            // Get the appropriate globe emoji for this timezone
            const globeEmoji = getGlobeEmoji(timezone);
            
            document.getElementById('timezoneValue').innerHTML = 
                `${localTime} (${tzAbbr}) ${globeEmoji}`;
        } else {
            document.getElementById('timezoneValue').innerHTML = 
                'Hopping between time zones... üêá';
        }
    } catch (error) {
        console.error('Error updating local time:', error);
        document.getElementById('timezoneValue').innerHTML = 
            'Calculating bunny time... üï∞Ô∏è';
    }
}

// Add this to your existing update cycle
setInterval(updateLocalTime, 1000); // Update every second ‚è±Ô∏è


// Basket and carrot counter variables üß∫ü•ï
let currentBasketCount = 0;
let targetBasketCount = 0;
let currentCarrotCount = 0;
let targetCarrotCount = 0;

// Add this helper function for formatting large numbers
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// Add this function to calculate current baskets
function calculateCurrentBaskets(now, currentStop, lastStop, nextStop) {
    if (!routeData || routeData.length === 0) return 0;
    
    // Pre-journey
    const easterEveStart = new Date(getEasterDates().easterEveDate);
    easterEveStart.setUTCHours(10, 0, 0, 0);
    if (now < easterEveStart) return 0;
    
    // Post-journey
    const easterDayEnd = new Date(getEasterDates().easterEveDate);
    easterDayEnd.setDate(easterDayEnd.getDate() + 1);
    easterDayEnd.setUTCHours(11, 10, 0, 0);
    if (now >= easterDayEnd) return 7706250000;
    
    // During a stop
    if (currentStop) {
        const stopStartTime = new Date(currentStop.arrival * 1000);
        const stopEndTime = new Date(currentStop.departure * 1000);
        const progress = Math.max(0, Math.min(1, 
            (now - stopStartTime) / (stopEndTime - stopStartTime)
        ));
        
        // Special handling for first real stop (London, Kiribati)
        if (lastStop && lastStop.City === "Easter Bunny's Workshop") {
            return Math.round(currentStop.basketsDelivered * progress);
        }
        
        const previousStopBaskets = lastStop ? lastStop.basketsDelivered : 0;
        const basketsToDeliver = currentStop.basketsDelivered - previousStopBaskets;
        
        return Math.round(previousStopBaskets + basketsToDeliver * progress);
    }
    
    // In transit between stops
    if (lastStop && nextStop) {
        const transitStartTime = new Date(lastStop.departure * 1000);
        const transitEndTime = new Date(nextStop.arrival * 1000);
        const progress = Math.max(0, Math.min(1,
            (now - transitStartTime) / (transitEndTime - transitStartTime)
        ));
        
        // Special handling for transit from workshop
        if (lastStop.City === "Easter Bunny's Workshop") {
            return Math.round(nextStop.basketsDelivered * progress);
        }
        
        const basketDifference = nextStop.basketsDelivered - lastStop.basketsDelivered;
        return Math.round(lastStop.basketsDelivered + basketDifference * progress);
    }
    
    return 0;
}

// Calculate current carrots eaten ü•ï
function calculateCurrentCarrots(now, currentStop, lastStop, nextStop) {
    if (!routeData || routeData.length === 0) return 0;
    
    // Pre-journey
    const easterEveStart = new Date(getEasterDates().easterEveDate);
    easterEveStart.setUTCHours(10, 0, 0, 0);
    if (now < easterEveStart) return 0;
    
    // Post-journey
    const easterDayEnd = new Date(getEasterDates().easterEveDate);
    easterDayEnd.setDate(easterDayEnd.getDate() + 1);
    easterDayEnd.setUTCHours(11, 10, 0, 0);
    if (now >= easterDayEnd) {
        const lastStopInJourney = [...routeData]
            .sort((a, b) => b.departure - a.departure)[0];
        return lastStopInJourney ? lastStopInJourney.carrotsEaten : 0;
    }
    
    // During a stop
    if (currentStop) {
        const stopStartTime = new Date(currentStop.arrival * 1000);
        const stopEndTime = new Date(currentStop.departure * 1000);
        const progress = Math.max(0, Math.min(1,
            (now - stopStartTime) / (stopEndTime - stopStartTime)
        ));
        
        // Special handling for first real stop (London, Kiribati)
        if (lastStop && lastStop.City === "Easter Bunny's Workshop") {
            return Math.round(currentStop.carrotsEaten * progress);
        }
        
        const previousStopCarrots = lastStop ? lastStop.carrotsEaten : 0;
        const carrotsToEat = currentStop.carrotsEaten - previousStopCarrots;
        
        return Math.round(previousStopCarrots + carrotsToEat * progress);
    }
    
    // In transit between stops
    if (lastStop && nextStop) {
        const transitStartTime = new Date(lastStop.departure * 1000);
        const transitEndTime = new Date(nextStop.arrival * 1000);
        const progress = Math.max(0, Math.min(1,
            (now - transitStartTime) / (transitEndTime - transitStartTime)
        ));
        
        // Special handling for transit from workshop
        if (lastStop.City === "Easter Bunny's Workshop") {
            return Math.round(nextStop.carrotsEaten * progress);
        }
        
        const carrotDifference = nextStop.carrotsEaten - lastStop.carrotsEaten;
        return Math.round(lastStop.carrotsEaten + carrotDifference * progress);
    }
    
    return 0;
}

// Update both baskets and carrots display with animation
function updateCounterDisplays(newBaskets, newCarrots) {
    const presentsValue = document.getElementById('presentsValue');
    const cookiesValue = document.getElementById('cookiesValue');
    
    if (presentsValue) {
        currentBasketCount = newBaskets;
        presentsValue.textContent = formatNumber(currentBasketCount);
    }
    
    if (cookiesValue) {
        currentCarrotCount = newCarrots;
        cookiesValue.textContent = formatNumber(currentCarrotCount);
    }
}


// Test mode toggle üß™
const TEST_MODE = true; // Set to true to simulate April 19th

// Helper function to get current date/time (real or test mode) üïí
function getCurrentDateTime() {
    let now = new Date();
    if (TEST_MODE) {
        // Create a new date with April 19th but keep current time
        return new Date(
            now.getFullYear(),  // Current year
            3,                  // April (0-based)
            19,                 // 19th
            now.getUTCHours(), // Replace with now.getUTCHours() for current hour
            now.getUTCMinutes(),
            now.getUTCSeconds()
        );
    }
    return now;
}

// Calculate Easter dates üìÖ
function getEasterDates() {
    const currentDate = getCurrentDateTime();
    const currentYear = currentDate.getFullYear();
    
    // Get Easter Eve dates for current and next year using our calculation function
    const easterEveDate = getEasterEveDate(currentYear);
    const nextYearEasterEveDate = getEasterEveDate(currentYear + 1);
    
    // Calculate days to adjust based on the 2023 route date (April 8)
    const reference2023Date = new Date(Date.UTC(currentYear, 3, 8)); // April 8, 2023
    const daysToAdjust = Math.round((easterEveDate - reference2023Date) / (1000 * 60 * 60 * 24));
    
    return {
        easterEveDate,
        nextYearEasterEveDate,
        daysToAdjust
    };
}

// Format countdown time ‚è±Ô∏è
function formatCountdown(seconds) {
    if (seconds >= 86400) { // 24 hours
        return Math.ceil(seconds / 86400) + 'd';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Fetch and process route data üõ£Ô∏è
let routeData = [];
async function fetchRouteData() {
  try {
    console.log('üîÑ Fetching Easter Bunny route data...');
    const response = await fetch('https://api.npoint.io/adf585d984bb6a571cb7');
    const data = await response.json();
        
    // Calculate the exact difference between 2023 route and 2025 route
    const route2023Start = new Date(2023, 3, 8, 10, 0, 0); // April 8, 2023 10:00 UTC
    const route2025Start = new Date(2025, 3, 19, 10, 0, 0); // April 19, 2025 10:00 UTC
    const timeDifferenceSeconds = Math.floor((route2025Start - route2023Start) / 1000);
        
    console.log('üìÖ 2023 Route Start:', route2023Start.toISOString());
    console.log('üìÖ 2025 Route Start:', route2025Start.toISOString());
    console.log('‚è±Ô∏è Time Difference (seconds):', timeDifferenceSeconds);
        
    // Process each stop
    routeData = data.route.map(stop => {
      // Adjust Unix timestamps by adding the exact difference
      const arrival = parseInt(stop["Unix Arrival"]) + timeDifferenceSeconds;
      const departure = arrival + parseInt(stop["Arrival Stoppage Time"]);
           
      return {
        ...stop,
        arrival,
        departure,
        basketsDelivered: Math.ceil(parseInt(stop["Eggs Delivered"]) * 1.25),
        carrotsEaten: Math.ceil(parseInt(stop["Carrots eaten"]) * 1.25)
      };
    });
        
    console.log('‚úÖ Route data processed successfully!');
    return true;
  } catch (error) {
    console.error('‚ùå Error fetching route data:', error);
    return false;
  }
}
// Add these at the top with other global variables
let lastWeatherUpdate = 0;
const WEATHER_UPDATE_INTERVAL = 10000; // 20 seconds in milliseconds

// Update Easter Bunny location and stats üê∞
function updateBunnyLocation() {
    try {
        const now = getCurrentDateTime();
        const formattedTime = now.toISOString().replace('T', ' ').slice(0, 19);
        console.log(`üïí [${formattedTime}] Updating bunny location...`);
        
        const { easterEveDate, nextYearEasterEveDate } = getEasterDates();
        
        const easterEveStart = new Date(easterEveDate);
        easterEveStart.setUTCHours(10, 0, 0, 0); // 10:00 AM UTC
        
        const easterDayEnd = new Date(easterEveDate);
        easterDayEnd.setDate(easterDayEnd.getDate() + 1);
        easterDayEnd.setUTCHours(11, 10, 0, 0); // 11:10 AM UTC next day
        
        // Update stats container elements
        const currentStopLabel = document.querySelector('#currentStopLabel');
        const currentStopValue = document.querySelector('#currentStopValue');
        const departingLabel = document.querySelector('#departingLabel');
        const departingValue = document.querySelector('#departingValue');
        const lastSeenValue = document.querySelector('#lastSeenValue');
        const currentSpeedValue = document.querySelector('#currentSpeedValue');


        // Helper function to update total distance
        function updateTotalDistance(newLat, newLon) {
            if (lastPosition) {
                const segmentDistance = calculateDistance(
                    lastPosition[0], lastPosition[1],
                    newLat, newLon
                );
                totalDistance += segmentDistance;
                updateDistanceDisplay(totalDistance);
            }
            lastPosition = [newLat, newLon];
        }
        
        // Helper function to set Easter Island location
        function setEasterIslandLocation(countdownTarget) {
            try {
                const islandPosition = [-27.1044228, -109.2489683];
                bunnyMarker.setLatLng(islandPosition);
                updateTotalDistance(islandPosition[0], islandPosition[1]);

        let unit = 'km/h';
        
        if (settings.units === 'imperial') {
            unit = 'mph';
        }
     
                
                currentStopLabel.innerHTML = '<span class="material-symbols-rounded">location_on</span> Current stop';
                currentStopValue.textContent = `${getRegionFlag("Easter Island, Chile")} Easter Bunny's Workshop, Easter Island, Chile`;
                departingLabel.innerHTML = '<span class="material-icons">flight_takeoff</span> The Easter Bunny lifts off in';
                lastSeenValue.textContent = "-";
                currentSpeedValue.textContent = `0 ${unit}`;
                
                // Update baskets and carrots for pre/post journey
                const finalBaskets = now < easterEveStart ? 0 : 7706250000;
                const finalCarrots = now < easterEveStart ? 0 : routeData[routeData.length - 1]?.carrotsEaten || 0;
                
                console.log(`üèùÔ∏è [${formattedTime}] Easter Island Stats:`, {
                    baskets: formatNumber(finalBaskets),
                    carrots: formatNumber(finalCarrots),
                    status: now < easterEveStart ? 'Pre-journey' : 'Post-journey'
                });
                
                if (targetBasketCount !== finalBaskets || targetCarrotCount !== finalCarrots) {
                    targetBasketCount = finalBaskets;
                    targetCarrotCount = finalCarrots;
                    updateCounterDisplays(finalBaskets, finalCarrots);
                }
                
                const countdown = Math.max(0, Math.floor((countdownTarget - now) / 1000));
                departingValue.textContent = formatCountdown(countdown);
                

                if (isMapLocked) {
                    map.setView(islandPosition, map.getZoom(), {animate: false});
                }
            } catch (error) {
                console.error(`‚ùå [${formattedTime}] Error in setEasterIslandLocation:`, error);
            }
        }

        // Helper function to check and update weather if needed
        function checkWeatherUpdate(lat, lon) {
            const currentTime = now.getTime();
            if (currentTime - lastWeatherUpdate >= WEATHER_UPDATE_INTERVAL) {
                lastWeatherUpdate = currentTime;
                updateWeather(lat, lon);
            }
        }
        
// Initialize distance if not done yet
if (!distanceInitialized) {
    initializeDistance(now);
}

        // Before journey starts or after journey ends
        if (now < easterEveStart || now >= easterDayEnd) {
            setEasterIslandLocation(now < easterEveStart ? easterEveStart : new Date(nextYearEasterEveDate));
            return;
        }
        
        // Find the last visited stop
        const lastStop = [...routeData]
            .filter(stop => now >= new Date(stop.departure * 1000))
            .sort((a, b) => b.departure - a.departure)[0];
        
        // Find next stop
        const nextStop = [...routeData]
            .filter(stop => now < new Date(stop.arrival * 1000))
            .sort((a, b) => a.arrival - b.arrival)[0];
        
        // During the journey
        const currentStop = routeData.find(stop => 
            now >= new Date(stop.arrival * 1000) && 
            now < new Date(stop.departure * 1000)
        );
       
        
        // Update last seen location
        if (lastStop) {
            lastSeenValue.textContent = `${getRegionFlag(lastStop.Region)} ${lastStop.City}, ${lastStop.Region}`;
        }
        
        // Calculate and update basket and carrot counts
        const newBasketCount = calculateCurrentBaskets(now, currentStop, lastStop, nextStop);
        const newCarrotCount = calculateCurrentCarrots(now, currentStop, lastStop, nextStop);
        
        
if (lastStop && lastStop.City === "Easter Bunny's Workshop") {
    const presentsValue = document.getElementById('presentsValue');
    const cookiesValue = document.getElementById('cookiesValue');

    presentsValue.textContent = "0";
    cookiesValue.textContent = "0";

    // Skip the update logic for basket and carrot counts
} else {
    if (newBasketCount !== targetBasketCount || newCarrotCount !== targetCarrotCount) {
        targetBasketCount = newBasketCount;
        targetCarrotCount = newCarrotCount;
        updateCounterDisplays(newBasketCount, newCarrotCount);
    }
}

        
        if (currentStop) {
            // At a stop
            // At a stop - speed is 0
            speedBuffer = []; // Clear speed buffer
            updateSpeedDisplay(0);


            const position = [parseFloat(currentStop.Latitude), parseFloat(currentStop.Longitude)];
            checkWeatherUpdate(position[0], position[1]);
            
            updateTotalDistance(position[0], position[1]);
            bunnyMarker.setLatLng(position);
            
            if (isMapLocked) {
                map.setView(position, map.getZoom(), {animate: false});
            }
            
            currentStopLabel.innerHTML = '<span class="material-symbols-rounded">location_on</span> Current stop';
            currentStopValue.textContent = `${getRegionFlag(currentStop.Region)} ${currentStop.City}, ${currentStop.Region}`;
            departingLabel.innerHTML = '<span class="material-icons">flight_takeoff</span> Departing in';
            
            const countdown = Math.max(0, Math.floor((currentStop.departure * 1000 - now) / 1000));
            departingValue.textContent = formatCountdown(countdown);
        } else if (lastStop && nextStop) {
            // In transit
            const timeProgress = (now - lastStop.departure * 1000) / 
                               (nextStop.arrival * 1000 - lastStop.departure * 1000);
            
            const lat = parseFloat(lastStop.Latitude) + 
                       (timeProgress * (parseFloat(nextStop.Latitude) - parseFloat(lastStop.Latitude)));
            const lng = parseFloat(lastStop.Longitude) + 
                       (timeProgress * (parseFloat(nextStop.Longitude) - parseFloat(lastStop.Longitude)));

            checkWeatherUpdate(lat, lng);

            // Calculate and update current speed
            const currentSpeed = calculateCurrentSpeed(lat, lng, now.getTime());
            updateSpeedDisplay(currentSpeed);
            
            const position = [lat, lng];
            
            updateTotalDistance(lat, lng);
            bunnyMarker.setLatLng(position);
            
            if (isMapLocked) {
                map.setView(position, map.getZoom(), {animate: false});
            }
            
            currentStopLabel.innerHTML = '<span class="material-symbols-rounded">directions</span> Next stop';
            currentStopValue.textContent = `${getRegionFlag(nextStop.Region)} ${nextStop.City}, ${nextStop.Region}`;
            departingLabel.innerHTML = '<span class="material-icons">flight_land</span> Arriving in';
            
            const countdown = Math.max(0, Math.floor((nextStop.arrival * 1000 - now) / 1000));
            departingValue.textContent = formatCountdown(countdown);
        }
    } catch (error) {
        console.error(`‚ùå [${formattedTime}] Error in updateBunnyLocation:`, error);
        console.error('Stack trace:', error.stack);
    }
}

// Fullscreen toggle function üñ•Ô∏è
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

// Lock toggle function with map control üîí
function toggleLock(button) {
    const icon = button.querySelector('.material-symbols-rounded');
    if (icon.textContent === 'lock') {
        // Unlock the map
        icon.textContent = 'lock_open';
        isMapLocked = false;
        map.dragging.enable();
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
    } else {
        // Lock the map
        icon.textContent = 'lock';
        isMapLocked = true;
        // Center on bunny
        map.setView(bunnyMarker.getLatLng(), map.getZoom());
        // Disable map interactions except zoom controls
        map.dragging.disable();
        map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
    }
}

// Initialize tracking system üöÄ
async function initializeTracking() {
    const success = await fetchRouteData();
    await fetchPreTrackingData();
    
    if (success) {
        // Initialize markers - now with await
        await initializeDestinationMarkers(); // üîÑ Added await here!
        
        // Update location and markers immediately
        updatePreTrackingStatus(getCurrentDateTime());
        updateBunnyLocation();
        updateMarkerStates();
        
// Add this to your existing update cycle in initializeTracking
setInterval(() => {
    const now = getCurrentDateTime();
    updatePreTrackingStatus(now);
    updateBunnyLocation();
    updateMarkerStates();
    updateLocalTime(); // Add this line to update the time every second
}, 1000);

        
        console.log('üéØ Tracking system and markers initialized!');
    }
}

// Start the tracking system
initializeTracking();

// Loading messages array
const loadingMessages = [
    "Connecting to Easter Island... üèùÔ∏è",
    "Checking the Easter Bunny's GPS coordinates... üìç",
    "Loading basket delivery data... üß∫",
    "Counting carrots and calculating routes... ü•ï",
    "Syncing with time zones around the world... üåç",
    "Warming up the map engines... üó∫Ô∏è",
    "Almost ready to track some Easter magic! ‚ú®"
];

// Simulate loading progress
let progress = 0;
const progressBar = document.getElementById("progressBar");
const loadingMessage = document.getElementById("loadingMessage");

function updateProgress() {
    progress += 10; // Increment progress
    progressBar.style.width = progress + "%";
    
    // Update message based on progress
    const messageIndex = Math.floor((progress / 100) * (loadingMessages.length - 1));
    loadingMessage.textContent = loadingMessages[messageIndex];
    
    if (progress < 100) {
        setTimeout(updateProgress, 500); // Update every 0.5 seconds
    } else {
        // Show final message before fade out
        loadingMessage.textContent = "Ready to hop into action! üê∞‚ú®";
        finishLoading();
    }
}

// Function to finish loading and show the tracker
function finishLoading() {
    const loadingScreen = document.getElementById("loadingScreen");
    const tracker = document.getElementById("tracker");
    
    loadingScreen.classList.add("fade-out"); // Add fade-out class
    setTimeout(() => {
        loadingScreen.style.display = "none"; // Hide loading screen
        tracker.style.display = "block"; // Show tracker
    }, 2000); // Wait for fade-out transition to finish
}

// Start loading process
updateProgress();

function applyDarkMode(enabled) {
    if (enabled) {
        document.documentElement.setAttribute('data-theme', 'dark');
        map.removeLayer(currentTileLayer);
        currentTileLayer = darkTileLayer;
        currentTileLayer.addTo(map);
        
        // Update map elements for dark mode
        const popupWrappers = document.querySelectorAll('.leaflet-popup-content-wrapper');
        const popupTips = document.querySelectorAll('.leaflet-popup-tip');
        const popupContents = document.querySelectorAll('.leaflet-popup-content');
        const tooltips = document.querySelectorAll('.leaflet-tooltip');
        
        popupWrappers.forEach(wrapper => {
            wrapper.style.backgroundColor = 'var(--popup-background)';
        });
        
        popupTips.forEach(tip => {
            tip.style.backgroundColor = 'var(--popup-background)';
        });
        
        popupContents.forEach(content => {
            content.style.color = 'var(--text-primary)';
        });

        tooltips.forEach(tooltip => {
            tooltip.style.backgroundColor = 'var(--tooltip-background)';
            tooltip.style.color = 'var(--text-primary)';
            tooltip.style.borderColor = 'var(--card-border)';
        });
    } else {
        document.documentElement.setAttribute('data-theme', 'light');
        map.removeLayer(currentTileLayer);
        currentTileLayer = lightTileLayer;
        currentTileLayer.addTo(map);
        
        // Reset map elements to default
        const popupWrappers = document.querySelectorAll('.leaflet-popup-content-wrapper');
        const popupTips = document.querySelectorAll('.leaflet-popup-tip');
        const popupContents = document.querySelectorAll('.leaflet-popup-content');
        const tooltips = document.querySelectorAll('.leaflet-tooltip');
        
        popupWrappers.forEach(wrapper => {
            wrapper.style.backgroundColor = '';
        });
        
        popupTips.forEach(tip => {
            tip.style.backgroundColor = '';
        });
        
        popupContents.forEach(content => {
            content.style.color = '';
        });

        tooltips.forEach(tooltip => {
            tooltip.style.backgroundColor = '';
            tooltip.style.color = '';
            tooltip.style.borderColor = '';
        });
    }
}

function saveSettings() {
    localStorage.setItem('bunnyTrackerSettings', JSON.stringify(settings));
    updateMetricsVisibility(); // Add this line
}

// Update the settings UI based on saved settings
function updateSettingsUI() {
    // Update metrics checkboxes
    document.getElementById('setting-location-info').checked = settings.metrics.locationInfo;
    document.getElementById('setting-delivery-stats').checked = settings.metrics.deliveryStats;
    document.getElementById('setting-island-status').checked = settings.metrics.islandStatus;
    document.getElementById('setting-arrival-time').checked = settings.metrics.arrivalTime;
    document.getElementById('setting-additional-stats').checked = settings.metrics.additionalStats;

    // Update units radio buttons
    document.getElementById('setting-metric').checked = settings.units === 'metric';
    document.getElementById('setting-imperial').checked = settings.units === 'imperial';

    // Update temperature radio buttons
    document.getElementById('setting-celsius').checked = settings.temperature === 'celsius';
    document.getElementById('setting-fahrenheit').checked = settings.temperature === 'fahrenheit';

    // Update dark mode checkbox
    document.getElementById('setting-dark-mode').checked = settings.darkMode;
}


function toggleSettings() {
    const backdrop = document.querySelector('.modal-backdrop');
    const popup = document.querySelector('.settings-popup');
    
    if (popup.style.display === 'block') {
        backdrop.classList.remove('active');
        popup.classList.remove('active');
        setTimeout(() => {
            backdrop.style.display = 'none';
            popup.style.display = 'none';
        }, 300);
    } else {
        backdrop.style.display = 'block';
        popup.style.display = 'block';
        // Force reflow
        popup.offsetHeight;
        backdrop.classList.add('active');
        popup.classList.add('active');
    }
}

// Update your DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    initializeMap();
    updateSettingsUI();
    updateMetricsVisibility();

    // Close button and backdrop click handlers
    document.querySelector('.settings-close').addEventListener('click', toggleSettings);
    document.querySelector('.modal-backdrop').addEventListener('click', toggleSettings);

    // Stop propagation on popup click to prevent closing when clicking inside
    document.querySelector('.settings-popup').addEventListener('click', (e) => {
        e.stopPropagation();
    });

    const metricIds = ['location-info', 'delivery-stats', 'island-status', 'arrival-time', 'additional-stats'];
    metricIds.forEach(id => {
        document.getElementById(`setting-${id}`).addEventListener('change', (e) => {
            const settingKey = id.split('-').map((word, index) => 
                index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
            ).join('');
            settings.metrics[settingKey] = e.target.checked;
            saveSettings();
        });
    });

    // Units radio buttons
    document.getElementById('setting-metric').addEventListener('change', (e) => {
        if (e.target.checked) {
            settings.units = 'metric';
            saveSettings();
        }
    });

    document.getElementById('setting-imperial').addEventListener('change', (e) => {
        if (e.target.checked) {
            settings.units = 'imperial';
            saveSettings();
        }
    });

    // Temperature radio buttons
    document.getElementById('setting-celsius').addEventListener('change', (e) => {
        if (e.target.checked) {
            settings.temperature = 'celsius';
            saveSettings();
        }
    });

    document.getElementById('setting-fahrenheit').addEventListener('change', (e) => {
        if (e.target.checked) {
            settings.temperature = 'fahrenheit';
            saveSettings();
        }
    });
    // Add dark mode listener
    document.getElementById('setting-dark-mode').addEventListener('change', (e) => {
        settings.darkMode = e.target.checked;
        applyDarkMode(e.target.checked);
        saveSettings();
    });
});

function updateMetricsVisibility() {
    // Location info (stops & timing)
    const stopDetailsCard = document.querySelector('.stop-details-card');
    if (stopDetailsCard) {
        stopDetailsCard.style.display = settings.metrics.locationInfo ? 'block' : 'none';
    }

    // Delivery stats (baskets & carrots)
    const presentsStats = document.querySelector('.presents-cookies');
    if (presentsStats) {
        presentsStats.style.display = settings.metrics.deliveryStats ? 'block' : 'none';
    }

    // Status stat contains Easter Island status
    const statusStat = document.querySelector('.status-stat');
    if (statusStat) {
        statusStat.style.display = settings.metrics.islandStatus ? 'block' : 'none';
    }

    // Estimated arrival time
    const arrivalStat = document.querySelector('.arrival-stat');
    if (arrivalStat) {
        arrivalStat.style.display = settings.metrics.arrivalTime ? 'block' : 'none';
    }

    // Additional stats (distance/speed/weather)
    const extraStats = document.querySelector('.extra-stats');
    if (extraStats) {
        extraStats.style.display = settings.metrics.additionalStats ? 'block' : 'none';
    }
}


function toggleInfo() {
    const infoPopup = document.getElementById('infoPopup');
    const infoBackdrop = document.getElementById('infoBackdrop');
    const isOpen = infoPopup.style.display === 'block';

    if (isOpen) {
        // Close popup
        infoBackdrop.classList.remove('active');
        infoPopup.classList.remove('active');
        setTimeout(() => {
            infoBackdrop.style.display = 'none';
            infoPopup.style.display = 'none';
        }, 300);
    } else {
        // Open popup
        infoBackdrop.style.display = 'block';
        infoPopup.style.display = 'block';
        setTimeout(() => {
            infoBackdrop.classList.add('active');
            infoPopup.classList.add('active');
        }, 10);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const infoBackdrop = document.getElementById('infoBackdrop');
    const closeInfoBtn = document.getElementById('closeInfoBtn');

    // Close handlers
    closeInfoBtn.addEventListener('click', toggleInfo);
    infoBackdrop.addEventListener('click', toggleInfo);
});

let countdownDismissed = false;

function calculateEaster(year) {
    // Meeus/Jones/Butcher algorithm for calculating Easter
    const a = year % 19;
    const b = Math.floor(year / 100);
    const c = year % 100;
    const d = Math.floor(b / 4);
    const e = b % 4;
    const f = Math.floor((b + 8) / 25);
    const g = Math.floor((b - f + 1) / 3);
    const h = (19 * a + b - d - g + 15) % 30;
    const i = Math.floor(c / 4);
    const k = c % 4;
    const l = (32 + 2 * e + 2 * i - h - k) % 7;
    const m = Math.floor((a + 11 * h + 22 * l) / 451);
    const month = Math.floor((h + l - 7 * m + 114) / 31);
    const day = ((h + l - 7 * m + 114) % 31) + 1;
    
    return new Date(Date.UTC(year, month - 1, day));
}

function getEasterEveDate(year) {
    const easterSunday = calculateEaster(year);
    const easterEve = new Date(easterSunday);
    easterEve.setDate(easterEve.getDate() - 1);
    easterEve.setUTCHours(10, 00, 0, 0); // Set to 8:30 AM UTC
    return easterEve;
}

function getTrackingEndDate(easterEve) {
    // Tracking ends 1 day after Easter Eve
    const endDate = new Date(easterEve);
    endDate.setDate(endDate.getDate() + 1);
    return endDate;
}

function getNextTrackingYear(now) {
    const currentYear = now.getFullYear();
    const currentEasterEve = getEasterEveDate(currentYear);
    const trackingEndDate = getTrackingEndDate(currentEasterEve);
    
    // If we're more than a week after tracking end date, show countdown for next year
    const oneWeekAfterEnd = new Date(trackingEndDate);
    oneWeekAfterEnd.setDate(oneWeekAfterEnd.getDate() + 7);
    
    if (now >= oneWeekAfterEnd) {
        return currentYear + 1;
    }
    return currentYear;
}

function updateCountdown() {
    const now = getCurrentDateTime();
    const targetYear = getNextTrackingYear(now);
    const startDate = getEasterEveDate(targetYear);
    const timeLeft = startDate - now;

    if (timeLeft > 0) {
        const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

        document.getElementById('countDays').textContent = String(days).padStart(2, '0');
        document.getElementById('countHours').textContent = String(hours).padStart(2, '0');
        document.getElementById('countMinutes').textContent = String(minutes).padStart(2, '0');
        document.getElementById('countSeconds').textContent = String(seconds).padStart(2, '0');

        const headerText = targetYear > now.getFullYear() 
            ? `until the Easter Bunny's ${targetYear} journey begins ‚è≥`
            : `until the Easter Bunny's journey begins ‚è≥`;
        document.querySelector('.countdown-container h3').textContent = headerText;
    }
}

function toggleCountdown() {
    const overlay = document.getElementById('countdownOverlay');
    if (overlay.style.display === 'none') {
        overlay.style.display = 'flex';
        overlay.classList.remove('hiding');
        // Start updating the countdown
        updateCountdown();
        window.countdownInterval = setInterval(updateCountdown, 1000);
    } else {
        overlay.classList.add('hiding');
        setTimeout(() => {
            overlay.style.display = 'none';
            // Clear the interval when hiding
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
                window.countdownInterval = null;
            }
        }, 500);
    }
}

function dismissCountdown() {
    countdownDismissed = true;
    const overlay = document.getElementById('countdownOverlay');
    overlay.classList.add('hiding');
    // Clear the interval when dismissing
    if (window.countdownInterval) {
        clearInterval(window.countdownInterval);
        window.countdownInterval = null;
    }
    setTimeout(() => {
        overlay.style.display = 'none';
    }, 500);
}

// Initialize with countdown hidden
const overlay = document.getElementById('countdownOverlay');
if (overlay) {
    overlay.style.display = 'none';
}

// Register service worker for offline support üöÄ
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(registration => {
        console.log('üéØ Service Worker registered successfully:', registration.scope);
      })
      .catch(error => {
        console.error('‚ùå Service Worker registration failed:', error);
      });
  });
}

// Function to update weather stat when offline
function updateWeatherOffline() {
  const weatherStat = document.querySelector('.weather-stat');
  if (weatherStat) {
    weatherStat.textContent = '‚ùå Weather unavailable offline';
  }
}

// Function to show offline notification
function showOfflineNotification() {
  const notificationText = document.createElement('div');
  notificationText.id = 'offline-notification';
  notificationText.innerHTML = `
    <span class="material-symbols-rounded">cloud_off</span>
    <span>You're offline, but you can still track the Easter Bunny with a little magic! üì∂üì¥‚ú®</span>
    <span class="material-symbols-rounded close-icon">close</span>
  `;
  document.querySelector('.header').insertAdjacentElement('afterend', notificationText);

  // Add event listener to the close icon
  document.querySelector('.close-icon').addEventListener('click', () => {
    const notification = document.getElementById('offline-notification');
    notification.classList.add('fade-out');
    setTimeout(() => {
      notification.remove();
    }, 500); // Adjust the duration to match the CSS transition
  });
}

// Check if offline on initial load
if (!navigator.onLine) {
  updateWeatherOffline();
  showOfflineNotification();
}

// Add event listeners for online/offline status changes
window.addEventListener('offline', () => {
  updateWeatherOffline();
  showOfflineNotification();
});
window.addEventListener('online', () => {
  const notificationBar = document.getElementById('offline-notification');
  if (notificationBar) {
    notificationBar.remove();
    document.body.classList.remove('offline-mode');
  }
});

// Add to your existing update functions
function updateMobileStats() {
    // Get current time and tracking end time
    const now = getCurrentDateTime();
    const { easterEveDate } = getEasterDates();
    const trackingEnd = new Date(easterEveDate);
    trackingEnd.setUTCHours(10, 0, 0, 0); // 10:00 AM UTC

    // Get mobile meta elements
    const metaIcon = document.getElementById('metaIcon-mobile');
    const metaLabel = document.getElementById('metaLabel-mobile');
    const metaValue = document.getElementById('metaValue-mobile');

    // Determine whether to show Easter Island status or last seen
    if (now >= trackingEnd) {
        // Show last seen (last stop)
        metaIcon.textContent = 'history';
        metaLabel.textContent = 'Last seen:';
        metaValue.textContent = document.getElementById('lastSeenValue').textContent;
    } else {
        // Show Easter Island status
        metaIcon.textContent = 'history';
        metaLabel.textContent = 'Last seen:';
        metaValue.innerHTML = document.getElementById('statusValue').innerHTML;
    }

    // Sync stop info and icon
    const currentStopLabel = document.getElementById('currentStopLabel');
    const mobileStopLabel = document.getElementById('currentStopLabel-mobile');
    mobileStopLabel.querySelector('.material-symbols-rounded').textContent = 
        currentStopLabel.querySelector('.material-symbols-rounded').textContent;
    mobileStopLabel.querySelector('.label-text').textContent = 
        currentStopLabel.textContent.trim().replace(/^\S+\s+/, '');
    
    document.getElementById('currentStopValue-mobile').textContent = 
        document.getElementById('currentStopValue').textContent;
    
    // Sync departing/arriving status
    const departingLabel = document.getElementById('departingLabel');
    const mobileDepartingLabel = document.getElementById('departingLabel-mobile');
    mobileDepartingLabel.textContent = 
        departingLabel.querySelector('.material-icons').textContent;
    
    document.getElementById('departingValue-mobile').textContent = 
        document.getElementById('departingValue').textContent;
    
    // Sync stats
    document.getElementById('presentsValue-mobile').textContent = 
        document.getElementById('presentsValue').textContent;
    document.getElementById('cookiesValue-mobile').textContent = 
        document.getElementById('cookiesValue').textContent;
    document.getElementById('distanceValue-mobile').textContent = 
        document.getElementById('distanceValue').textContent;
    document.getElementById('currentSpeedValue-mobile').textContent = 
        document.getElementById('currentSpeedValue').textContent;
    
    // Sync time and weather
    document.getElementById('timezoneValue-mobile').textContent = 
        document.getElementById('timezoneValue').textContent;
    document.getElementById('weatherValue-mobile').textContent = 
        document.getElementById('weatherValue').textContent;
    
    // Sync arrival
    document.getElementById('arrivalValue-mobile').textContent = 
        document.getElementById('arrivalValue').textContent;
}

// Add click handler for mobile arrival estimator
function initializeMobileArrivalEstimator() {
    const arrivalSection = document.getElementById('arrivalSection-mobile');
    const arrivalValue = document.getElementById('arrivalValue-mobile');
    
    arrivalSection.addEventListener('click', () => {
        if (!userLocation) {
            handleLocationAccess();
        }
    });
}

// Update your DOMContentLoaded event listener to include mobile initialization
document.addEventListener('DOMContentLoaded', () => {
    initializeMobileArrivalEstimator();
});


// Add this to your existing update cycle
setInterval(updateMobileStats, 1000); // Update every second ‚è±Ô∏è
    </script>
</body>
</html>
